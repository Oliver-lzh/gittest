# 二分法



### [744. 寻找比目标字母大的最小字母 - 力扣（LeetCode）](https://leetcode.cn/problems/find-smallest-letter-greater-than-target/)

第一次做：

```c++
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target)
    {
        int left=0,right=letters.size()-1;

        while(left<=right)
        {
            int middle=left+(right-left)/2;

            if(letters[middle]>=target)
            {
                right=middle-1;;
            }
            else 
            {
                left=middle+1;;
            }
        }
        return letters[left % letters.size()];
    }
};
```

这里的代码主要是问题是 if(letters[middle]>=target)，这里错误的向左移动了，导致比如等于了这个target值后，但是还是向左移动再-1，那么题目条件要求的是严格大于target,这样left就过度左移导致值是不对的。

正确做法:

```c++
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target)
    {
        int left=0,right=letters.size()-1;

        while(left<=right)
        {
            int middle=left+(right-left)/2;

            if(letters[middle]<=target)
            {
                left=middle+1;;
            }
            else
            {
                right=middle-1;
            }
        }
        return letters[left % letters.size()];
    }
};
```

- return letters[left % letters.size()]; 这句代码的意思是能够返回当target大于所有的值是可以循环回来第一个字符。

![image-20251213161234111](C:\software-1\Typora\image\image-20251213161234111.png)

当前面的数小的时候，直接返回前面这个数，就是正常的这个情况。