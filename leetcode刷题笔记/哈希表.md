# 哈希表





## 一、有效的字母异位词

## Q1

​	以下这个写法是错误的，数组的个数要确定，因此个数不能为变量。

```c
int i=6;
int array[i]={0};
```

**variable-sized object may not be initialized except with an empty initializer**



## 题解

```c
bool isAnagram(char* s, char* t)
{
    int len1=0,len2=0;
    len1=strlen(s);
    len2=strlen(t);


    if(len1!=len2)
    {
        return false;
    }
    int has1[26]={0};
    int has2[26]={0};

    for(int i=0;i<len1;i++)
    {
        has1[s[i]-'a']+=1;
        has2[t[i]-'a']+=1;
    }

    for(int i=0;i<26;i++)
    {
        if(has1[i]!=has2[i])
        {
            return false;
        }
    }
    return true;
}
```





## 二、二个数组的交集

思路：就是记录索引出现的次数后，然后和另一个数组进行比较。

### 题解

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize)
{
    int nums1Cnt[1001]={0};
    int lessSize=nums1Size<nums2Size? nums1Size:nums2Size;
    int *result=(int *)calloc(lessSize,sizeof(int));
    int resultIndex=0;
    int *tmpNums;

    int i;

    //记录出现的数字
    for(i=0;i<nums1Size;i++)
    {
        nums1Cnt[nums1[i]]++;
    }

    for(i=0;i<nums2Size;i++)
    {
        if(nums1Cnt[nums2[i]]>0)//判断是否出现过在1数组中，出现过就会保存出现次数
        {
            result[resultIndex]=nums2[i];
            resultIndex++;
            nums1Cnt[nums2[i]]=0;//避免重复出现返回
        }
    }

    *returnSize=resultIndex;

    return result;
}
```



## 三、二数之和



### 基础概念

使用std::unordered_map这个容器需要引用头文件<unorder_map>。

使用:

```c++
unorder_map<key,value> map; //map是是对象的名字 key就是代表位置，比如数组的索引，value就是里面存放的数值
```

这个类型的对象有以下的功能函数可以使用：

- map.size()计算个数
- map.insert(key,value) 添加一个键值对 通常搭配pair这个类型进行使用
- map.find(x)  //返回值为x的元素位置，即key，查到的是key的这个值，所以对于本题就是将数组的数值作为key来存放
- map.count(x) //返回值为x的元素的个数
- map.erase()
- m[key]
- map.begin() 返回指向第一个元素的迭代器  map.end() 返回最后一个元素的迭代器，就是键值的最后一个位置。

vector就是声明一个可以存放任意类型的动态数组。

it->second 表示返回的是key的值（value），it->first 表示返回的是key。

由于要查找元素是否出现过，因此把里面的元素作为key来查找。



### 分析

检查元素是否在一个集合出现过的时候考虑用到哈希表， map的作用就是查找key是否之前出现过，因此这道题我们查找的是元素因此key用来存放元素来查询是否出现过。



创建一个unordered_map的哈希表。因为需要查找的是value的值是否出现过，因此将查找的元素放在key上，数组的索引放在哈希表的value上。

通过判断当前查找的目标值是否在哈希表出现过来处理，如果出现过就返回当前的i和value，遍历中如果没有出现过就把差值存放在哈希表中。

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target)
    {
        //对于这道题他的value表示的是下标（it->second）
        //创建一个哈希表无序的，key 和value 都是int值
        std::unordered_map<int,int> map;

        for(int i=0;i<nums.size();i++)
        {
            //声明一个迭代器iter
            auto iter=map.find(target-nums[i]);//找不到的返回值是end，因为这个函数查找的是key，存放的就是数据
            if(iter!=map.end())
                return {iter->first,i};
            //没有找到对应的元素，放出到哈希表中
            map.inser(pair<int,int>(i,nums[i]));//成为了哈希表的元素
        }
        return {};
    }
};
```



## 五、赎金信



### 分析

题目要求使用magazine里面的字符去构建一个新的字符Note,而且Note中的字符只能出现一次，换句话说Note最长就是由26个不用字母组成，最大长度只有26，因为数据有限，因此可以采用数组的哈希表来实现。以下是解题过程：

1. 遍历magazine字符串里面字母出现的个数，用一个数组存储起来个数。
2. 遍历Note字符串，将每一次编译出现过的字母在这个数组中减去。
3. 若每一次遍历中出现有负数的位置，说明magazine中没有这个字符，因此无法构成Note，返回false。若遍历完没有出现负数，说明可以构成，返回true。

### 题解

自己写的版本

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine)
    {
        unordered_map<char,int> map;
        for(char a:magazine)
        {
            map[a]++;
        }

        for(char b:ransomNote)
        {
            if(map.find(b)!=map.end())
            {
                map[b]--;
            }
            else
            {
                return false;
            }
        }

         for(int i=0;i<map.size();i++)
        {
            if(map[i]!=0)
            {
                return false;
            }
        }
        return true;    
    }
};
```

存在的问题有不需要for再去检查是否出现过,若是小于0自动返回没有就可以。

修改后：

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine)
    {
        unordered_map<char,int> map;
        for(char a:magazine)
        {
            map[a]++;
        }

        for(char b:ransomNote)
        {
            if(map[b]>0)
            {
                map[b]--;
            }
            else
            {
                return false;
            }
        }

        return true;    
    }
};
```

官方的版本

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine)
    {
        int nums1[26]={0};

        if(ransomNote.size()>magazine.size())
        {
            return false;
        }

        //遍历magic 记录每个字母出现的次数
        for(int i=0;i<magazine.size();i++)
        {
            nums1[magazine[i]-'a']+=1;
        }

        for(int i=0;i<ransomNote.length();i++)
        {
            nums1[ransomNote[i]-'a']--;

            //如果小于0 说明Note中的字符magic没有
            if(nums1[ransomNote[i]-'a']<0)
            {
                return false;
            }
        }
        return true;
    }
};
```



## 六、水果成蓝



### 分析

集合滑动窗口来统计这个窗口里面不同2个数，出现最多的情况，因此需要在遍历的时候记录每个数出现的次数，以及滑动左边的时候需要进行重置出现的次数来进行下一次的统计

1. 首先右窗口进行遍历，同时记录同样键值出现的次数
2. 当有2个以上不同的键值出现的时候，这时候就要更新窗口，具体就是从左边窗口寻找键值，进行次数减少的操作，如果等于0就清除这个键值，同时也要对左边窗口进行移动，直到遍历完整个数组。

```c++
class Solution {
public:
    int totalFruit(vector<int>& fruits)
    {
        int n=fruits.size();
        unordered_map<int,int> cnt;

        int left=0,ans=0;
        for(int right=0;right<n;++right)
        {
            ++cnt[fruits[right]];
            while(cnt.size()>2)
            {
                auto it=cnt.find(fruits[left]);
                --it->second;
                if(it->second==0)
                {
                    cnt.erase(it);
                }
                ++left;
            }
            
            ans=max(ans,right-left+1);
        }
        return ans;
    }
};
```



## 七、三数之和

### 1题目

### 2遇到问题

去重的处理不清楚是怎么样的，分别要对abc进行出重；同时while循环的条件不是非常的明白。对于非重复的三元组一开始不是很理解，就是一个数组是三个元素组成的，每一个数组和数组之前的对比不能重复，如{1,1,-2} {1,1,-2}。

### 3.题目分析

首先运用排序算法，将这个数组进行排序。运用双指针的方法进行遍历这个数组，指针一个在数组最前面，一个在最后面，中间进行遍历，组成三个数。如果加起来过大，就将数组最右边的指针进行向前移动，如果过小就把最左边的向右移动，如果相等将三个数保存在一个动态数组里面，其次对左右2遍的数组进行去重。

总体来说就是滑动窗口+双指针+去重处理

1. 排序数组
2. 定义左右指针，进行遍历整个数组，中间进行i（中间指针）的去重
3. 条件语句进行处理
4. 相等左右缩减，和左右指针的去重的处理，直到左右指针相遇，进行下一轮i的循环

### 4题解

自己写的代码

1.sum的加和移除问题

2.相等之后的处理不对并且双指针的结束条件不对

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums)
    {
        vector<vector<int>> result;
        sort(nums.begin(),nums.end());
        for(int i=0;i<nums.size();i++)
        {
            int left=i+1;
            int right=nums.size();

            float sum=0;
            sum=nums[i]+nums[left]+nums[right];

            if(sum>0)
            {
                right--;
            }
            else if(sum<0)
            {
                left++;
            }
            else 
            {
                 result.push_back({nums[i], nums[left], nums[right]}); 
            }
        }
    return result;
    }
    };
```

A的出重逻辑是和前面的比对非后面的逻辑。

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        // 找出a + b + c = 0
        // a = nums[i], b = nums[left], c = nums[right]
        for (int i = 0; i < nums.size(); i++) {
            // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
            if (nums[i] > 0) {
                return result;
            }
            // 错误去重a方法，将会漏掉-1,-1,2 这种情况
            /*
            if (nums[i] == nums[i + 1]) {
                continue;
            }
            */
            // 正确去重a方法
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
                // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组
                /*
                while (right > left && nums[right] == nums[right - 1]) right--;
                while (right > left && nums[left] == nums[left + 1]) left++;
                */
                if (nums[i] + nums[left] + nums[right] > 0) right--;
                else if (nums[i] + nums[left] + nums[right] < 0) left++;
                else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;

                    // 找到答案时，双指针同时收缩
                    right--;
                    left++;
                }
            }
        }
        return result;
    }
};
```



## 八、四数相加二

### 1.题目

![image-20250223135657694](C:\software-1\Typora\image\image-20250223135657694.png)

### 2.遇到的问题

看到这个题目的反应就是使用循环遍历的方法进行解答，没有什么别的思路。这章明确是使用哈希表，但是没有完全理解哈希表的本质和什么时候使用哈希表。

### 3.题目分析

在需要查找是否出现过或者查找匹配相关的题目中，需要用到哈希表来解决问题。

- 首先统计A,B2个数组的所有可能结果，并且将重复的结果进行相加，因为查找的是结果，因此key表示AB元素的相加值，value表示的是sum相加的出现次数。
- 统计CD数组的所有结果，并且在表中查找是否出现过
- 将出现过能在哈希表中查找到的结果进行统计，注意有一次匹配就是要统计value的值而不是一次的相加导致统计减少

### 4.题解

官方代码：

```c++
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        unordered_map<int, int> umap; //key:a+b的数值，value:a+b数值出现的次数
        // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中
        for (int a : A) {//a指向的是A里面的元素，作为一个迭代器来使用。
            for (int b : B) {
                umap[a + b]++;//这里可以表示为 a+b为键值，次数为values
                //也可以用这个方式表达
                //int sum=a+b;
                //map[sum]++;
            }
        }
        int count = 0; // 统计a+b+c+d = 0 出现的次数
        // 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。
        for (int c : C) {
            for (int d : D) {
                if (umap.find(0 - (c + d)) != umap.end()) 
                {
                    count += umap[0 - (c + d)];
                }
            }
        }
        return count;
    }
};
```

![image-20250223140935494](C:\software-1\Typora\image\image-20250223140935494.png)

自己的思路写的代码

```c++
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) 
    {
        unordered_map<int,int> map;
        int count=0;
        //遍历A和B组的相加的所有情况，相加的结果为键值，出现过的次数为value
        for(int i=0;i<A.size();i++)
        {
            for(int j=0;j<B.size();j++)
            {
                int sum=0;
                sum=A[i]+B[j];
                auto it=map.find(sum);
                if(it!=map.end())
                {
                    it->second++;
                }

                map.insert({sum,1});//写入值并且设置为1次
            }
        }

        
        for(int i=0;i<C.size();i++)
        {
            for(int j=0;j<D.size();j++)
            {
                int sum=-(C[i]+D[j]);
                auto it=map.find(sum);
                if(it!=map.end())//找到一样的值
                {
                    count += map[sum]; // 直接累加出现次数  
                }
            }
        }
        return count;
    }
};
```



这个代码错误的原因是因为统计少了个数，如果AB的值是出现过2次的，我这个操作只会+1，实际应该是有2个值和他想匹配导致次数减少。

```c++
  if(it!=map.end())//找到一样的值
                {
                    it->second--;
                    count++;
                }
               因此正确应该修改为：
            count=cout+map[sum]; //之前的统计到的个数，加上目前配置哈希表中拥有的个数，那么这个个数就是value值，这个值的表示方法就是map[sum]表示。
                
```



## 九、四数相加

### 1.题目

![image-20250226112416715](C:\software-1\Typora\image\image-20250226112416715.png)

### 2.遇到问题

1.去重的处理还不是很熟练以及剪枝的处理也不熟悉

### 3.题目分析

和三数之后一样，就是使用滑动窗口加双指针的方法进行解题。但是剪枝处理和2层的for循环的去重需要重点关注。

### 4.题解

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) 
    {
        vector<vector<int>> result;
        sort(nums.begin(),nums.end());

        for(int k=0;k<nums.size();k++)
        {

          if (nums[k] > target && nums[k] >= 0) {
            	break; // 这里使用break，统一通过最后的return返回
            }
            // 对nums[k]去重
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }

            for(int i=k+1;i<nums.size();i++)
            {
                
               // 2级剪枝处理
                if (nums[k] + nums[i] > target && nums[k] + nums[i] >= 0) {
                    break;
                }

                // 对nums[i]去重
                if (i > k + 1 && nums[i] == nums[i - 1]) {
                    continue;
                }

                int left=i+1;
                int right=nums.size()-1;

                while(right>left)
                {
                    if((long)nums[k]+nums[i]+nums[left]+nums[right]>target) right--;
                    else if((long)nums[k]+nums[i]+nums[left]+nums[right]<target) left++;
                    else
                    {
                        result.push_back(vector<int>{nums[k],nums[i],nums[left],nums[right]});
                        while(right>left && nums[right]==nums[right-1]) right--;
                        while(right>left && nums[left]==nums[left+1]) left++;

                        right--;
                        left++;
                    }
                }
            }
        }
        return result;
    }
};
```

