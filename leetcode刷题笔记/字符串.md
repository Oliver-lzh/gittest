## 一、反转字符串

### 1.题目

![image-20240907204027821](C:\software-1\Typora\image\image-20240907204027821.png)

### **2.遇到问题**

Q1:

strlen()和size都不计算结尾的空运算符‘/0’。

### 3.题目分析

这道题可以采用左右指针的方法进行解答，交换2个指针的值，交换后对指针进行移动。上述操作知道左指针等于（偶数个的话刚好相等还要交换一下）或者大于右指针的时候结束。

### 4.代码解答

```c++
class Solution {
public:
    void reverseString(vector<char>& s)
    {
        int left=0;
        int right=s.size()-1;
        while(left<=right)
        {
            char mid=s[right];
            s[right]=s[left];
            s[left]=mid;

            left++;
            right--;
        }
    }
};
```

## 二、反转字符串二

### 1.题目

![image-20240908103056260](C:\software-1\Typora\image\image-20240908103056260.png)

解释：这个题目的意思是将一个字符串切割成2k为步长的一段一段，其中前k个字符进行翻转。

### 2.遇到问题

**Q1**

​	前面一题是处理2个字符进行翻转，可以用中间变量完成操作，这道题需要翻转的数量是变量k的值，因此一开始不了解如何处理。查看资料后，可以使用reverse这个库函数进行处理。

​	reverse用法如下：

参数1：字符串开始的位置，一般使用s.begin（）来表示。同时可以在这个表达式之后使用i来调整开始的位置。

参数2：字符串结束的位置，一般使用s.end（）来表示。

**Q2**

​	因为每一次处理的步长是2k，因此可以在for循环的最后一个参数来进行步长的调整应该为for（i=0;i<s.size();i+=2*k）

### 3.题目分析

​	在解决如何进行翻转的问题后，就要分类来讨论2中情况：

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

这2个条件的分界条件可以得出是当前i的开始位置+k和字符串的长度来进行分类。

### 4.题解

```c++
class Solution {
public:
    string reverseStr(string s, int k)
    {
        int start=0,end=2*k;

        //for循环的最后一个条件可以控制每一次的步长，因此不要局限于i++
        for(int i=0;i<s.size();i+=2*k)
        {
            //1.每隔2k反转钱前k个
            //2.剩余字符小于2k但是大于k个，则反转前k个。
           if(i+k<=s.size())
            {
                reverse(s.begin()+i,s.begin()+i+k);
            }
            else//剩下的字符少于k个
            {
                reverse(s.begin()+i,s.end());
            }
        }
        return s;
    }
};
```



## 三、替换数字

### 1.题目

![image-20240909092948723](C:\software-1\Typora\image\image-20240909092948723.png)

### 2.遇到问题

**Q1**

开始遇到字符串的数字不知道如何处理，想的是如何填充number进去，但是字符串的空间有限无法直接填充，因此解决方法就是填充。

**Q2**

为了不适用辅助空间对完成操作，使用左右指针来操作。过程为：

1.定义2个指针，一个指向旧字符串的末尾，一个指向扩充后的末尾。

2.遇到字符就把旧字符串的字符赋值给新字符串的指针，遇到数字就反向填充‘number’。

![image-20240909093642862](C:\software-1\Typora\image\image-20240909093642862.png)



### 3.题目分析

1.遍历旧字符串拥有数字的个数，方便后续扩充。

2.扩充字符串同时使用使用2个指针定位字符串的末尾

3.分类讨论，遇到数字就反向填充‘number’，遇到字母就正常交换。



### 4.题解

```c++
#include <iostream>
using namespace std;

int main()
{
    string s;
    while(cin>>s) //标准输入流 输入一个字符串
    {
        int Oright=s.size()-1;//字符的末尾指针
        int count=0;//统计数字的个数
        
        for(int i=0;i<s.size();i++)
        {
            if(s[i]>='0'&&s[i]<='9')
            {
                count++;
            }
        }
        
        //单词的字母是6个，但是你数字之前占用了一个空间，因此申请5个就行
        s.resize(s.size()+count*5);
        int Nright=s.size()-1;
        
        while(Oright>=0)//指向旧字符串
        {
            // 旧字符串出现数字，就在新字符串后反着生成number
            if(s[Oright]>='0'&&s[Oright]<='9')
            {
                s[Nright--] = 'r';
                s[Nright--] = 'e';
                s[Nright--] = 'b';
                s[Nright--] = 'm';
                s[Nright--] = 'u';
                s[Nright--] = 'n';
            }
            else
            {
                s[Nright--]=s[Oright];
            }
            Oright--;
        }
        cout<<s<<endl;
    }
}
```

## 四.反转字符串中的单词



### 1.题目

![image-20240910102345578](C:\software-1\Typora\image\image-20240910102345578.png)

### 2.遇到问题

**Q1**

  一开始不知道如何处理空格，通过查阅了解到了之前数组中刷过的一道移除元素的题目，在这个基础上将多余的空格移除。使用快慢指针在同一个字符串赋值的方法。

**Q2**

  在处理空格的基础上，如何控制每一个单词之间有一个空格。因此就使用到了while（）这个循环条件，通过每次处理一个单词来增加空格

-  if (slow != 0) s[slow++] = ' ';  作用：（1）第一个单词不用插入空格 （2）在处理一个单词后插入空格
- while (i < s.size() && s[i] != ' ') 作用：处理一个单词



### 3.题目分析

1.删除多余的空格，申请一个字符串空间。移除空格的操作

2.对整个字符串进行翻转

3.对单词进行翻转

### 4.题解

```c++
class Solution {
public:

    void reverse(string &s,int start,int end)
    {
        for(int i=start,j=end;i<j;i++,j--)
        {
            swap(s[i],s[j]);
        }
    }

    void RemoveSpace(string &s)
    {

        int slow = 0;   //整体思想参考
        for (int i = 0; i < s.size(); ++i) { //
            if (s[i] != ' ')
            { //遇到非空格就处理，即删除所有空格。
                if (slow != 0) s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。
                while (i < s.size() && s[i] != ' ')
                { //补上该单词，遇到空格说明单词结束。
                    s[slow++] = s[i++];
                }
            }
        }
        s.resize(slow); //slow的大小即为去除多余空格后的大小。
    }

    string reverseWords(string s)
    {
    //移除多余空格
    RemoveSpace(s);
    //整个字符串反转
    reverse(s,0,s.size()-1);

    int start=0;
    for(int i=0;i<=s.size();++i) //这里为什么是等于？？
    {
        //遍历到最后(只有一个单词的情况)或者是等于空格
        if(i==s.size() || s[i]== ' ')
        {
            reverse(s,start,i-1);
            start=i+1;
        }
    }
    return s;
    }
};
```



## 五、右转字符串

### 1.题目

![image-20240911111553514](C:\software-1\Typora\image\image-20240911111553514.png)

### 2.遇到问题

**Q1**

  遇到的第一个问题就是使用了双指针进行解题，发现无法解决，在现有的空间中无法完成交换的逻辑。

### **3.题目分析**

  本题可以使用整体反转和局部翻转的思路进行解答，同时也可以局部翻转后再整体。这道题提供的新思路就是可以通过这种局部和整体翻转的思路进行解题。

### 4.题解

```c++
#include <iostream>
#include <algorithm>
using namespace std;


int main()
{
    int n;//要反转的个数
    string s;
    
    cin>>n;
    cin>>s;

    int len=s.size();
    
    reverse(s.begin(),s.end());
    reverse(s.begin(),s.begin()+n);
    reverse(s.begin()+n,s.end());
        
     
     cout<<s<<endl;
    
}


```



## 6.找出字符串的匹配项

### 1.题目

![image-20240912104533294](C:\software-1\Typora\image\image-20240912104533294.png)

### 2.遇到问题

**Q1**

无法想到连续匹配的方法，只能想了如何单个匹配的方法，导致无法处理。

```c++
class Solution {
public:
    int strStr(string haystack, string needle)
    {
        int FatherStrLen=haystack.size();
        int SonStrLen=needle.size();
        int result=0;
        if(SonStrLen>FatherStrLen) return -1;

        for(int i=0;i<FatherStrLen;i++)
        {
            if(haystack[i]==needle[i])
            {
                result++;
            }
            if(result==SonStrLen)
            {
                break;
            }
        }

        return result-1;

    }
};
```

