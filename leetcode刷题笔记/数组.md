# 数组



## 一、二分法查找

题目

![image-20240620223843701](C:\Users\Oliver\AppData\Roaming\Typora\typora-user-images\image-20240620223843701.png)



第一种情况：

左右数组的区间为左闭右闭。

1.因此在while循环的条件就是left<=right。因此取的是左右闭的区间，左右的值都可以取到，因此循环条件可以取到等于号。

2.其次在更新左右区间的时候  在更新左区间时候 left=millde+1。+1的原因是middl这个值已经不是要找的target值，因此在跟新的时候可以将这个middl值排除在外，向前移动一个值。右区间同理为：right=millde-1。

代码如下：

```c
int search(int* nums, int numsSize, int target) 
{
    int middle=0,left=0;
    int right=numsSize-1;

    //这里使用的是[)的一个区间，因此下面处理的时候，需要在while循环和right更新的时候发生一定的变化，
    while(left<=right)
    {
        middle=left+(right-left)/2; //为了防止溢出 
        if(nums[middle]>target)
        {
            right=middle-1;
        }
        else if(nums[middle]<target)
        {
            left=middle+1;
        }
        else if(nums[middle]==target)
        {
            return middle;
        }
    }
    //通过这个循环没有找到对应的target
    return -1;
}
```

第二种情况：

左区间为闭区间，右区间为开区间。与第一种方案的区别如下：

1.while循环的条件为left<right。不能取得等于号，因为右边是开区间，相等是没有意义的，也就是说不可能相等。

2.更新左区间不变 left=middle+1,右区间因为是开区间，target值不能排除与右边的不相等，因此更新为right=middle。

代码如下：

```c
int search(int* nums, int numsSize, int target) 
{
    int middle=0,left=0;
    int right=numsSize-1;

    //这里使用的是[)的一个区间，因此下面处理的时候，需要在while循环和right更新的时候发生一定的变化，
    while(left<right)
    {
        middle=left+(right-left)/2; //为了防止溢出 
        if(nums[middle]>target)
        {
            right=middle;
        }
        else if(nums[middle]<target)
        {
            left=middle+1;
        }
        else if(nums[middle]==target)
        {
            return middle;
        }
    }
    //通过这个循环没有找到对应的target
    return -1;
}
```



## 相似题目

LeetCode 34 在排序数组中查找元素的第一个和最后一个位置

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* searchRange(int* nums, int numsSize, int target, int* returnSize) 
{
    int left=SearchLeftBorder(nums,numsSize,target);
    int right=SearchRightBorder(nums,numsSize,target);

    *returnSize=2;
    int *resnum=(int *)malloc(sizeof(int)*2);
    resnum[0]=left;
    resnum[1]=right;
 
    return resnum;
}

int SearchLeftBorder(int *nums,int numsSize,int target)
{
        int left=0,right=numsSize-1;
        int middle=0;
        while(left<=right)
        {
            middle=left+(right-left)/2;
            if(nums[middle]==target)
            {
                if(nums[middle-1]!=nums[middle]||middle==0)
                {
                   return middle;
                }
                else
                {
                    right=middle-1;
                }
            }

            else if(nums[middle]>target)
            {
                right=middle-1;
            }
            else
            {
                left=middle+1;
            }
        }
        return -1;
}

int SearchRightBorder(int *nums,int numsSize,int target)
{
        int left=0,right=numsSize-1;
        int middle=0;
        while(left<=right)
        {
            middle=left+(right-left)/2;
            if(nums[middle]==target)
            {
                if(nums[middle+1]!=nums[middle]||middle==numsSize-1)
                {
                    return middle;
                }
                else
                {
                    left=middle+1;
                }
            }

            else if(nums[middle]>target)
            {
                right=middle-1;
            }
            else
            {
                left=middle+1;
            }
        }
        return -1;
}
```

总结：在处理mid==target的时候，之前困惑的点是如何处理是否这个target值是否是第一个的target值。解决方法是：因为数组是顺序的，因此我们可以把最获得的target值与旁边的比较来得出是否是第一个值和最后一个值。第一个值的思路就是和它左边的一个数对比是否相等，不相等就是首个target。最后一个target值也是这么同样的思路，对比其右边一个值，如果不相等则是最后一个target。

```c
int mySqrt(int x) {
    int left=0,right=x;
    int middle;
    int res;
    if(x==0)
    {
        return 0;
    }
    left=1;
    while(left<=right)
    {
        middle=left+(right-left)/2;
        if(middle<=x/middle)// 这里使用mid*mid会出现溢出的问题。
        {
            res=middle;
            left=middle+1;
        }
        else
        {
            right=middle-1;
        }
       
    }
    return res;
}
```

1.mid*mid可能会导致溢出的问题，因此我们使用除法来处理一下。

## 二、移除元素

**题目：**

![image-20240905194841364](C:\software-1\Typora\image\image-20240905194841364.png)

**分析：**

首先需要定义2个指针，即快慢指针，一个（快指针）负责遍历整个数组一个（慢指针）负责存储不重复的新数组。

**代码：**

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) 
    {
        int slow=0;
        int fast=0;
        for(;fast<nums.size();fast++)
        {
            if(nums[fast]!=val)
            {
                nums[slow]=nums[fast];
                slow++;
            }
        }
        return slow;
    }
};
```



## 三、有序数组的平方

分为2种类型，按照题目的需要来选择。

- 快慢指针
- 左右指针

**题目：**

![image-20240704093454267](C:\software-1\Typora\image\image-20240704093454267.png)

分析：题目关键在于这个是一个**非递减的数组**。因此，数组的的大小是从边缘到中间递减的，可以创建一个新的数组，使用左右指针来比较大小，放入新数组的末尾，同时更新快慢指针和新数组的索引，

![image-20240704094029122](C:\software-1\Typora\image\image-20240704094029122.png)



第二次做代码：

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums)
    {
        vector<int> result;

        int left=0,right=0;
        int index=0;

        while(nums[right]<0)
        {
            right++;
        }
        left=right-1;

        for(int i=0;i<nums.size();i++)
        {
            long leftdouble=nums[left]*nums[left];
            long rightdouble=nums[right]*nums[right];

            if(leftdouble>rightdouble)
            {
                result.push_back(rightdouble);
                right++;
            }
            else
            {
                result.push_back(leftdouble);
                left--;
            }
        }
        return result;
    }
};
```

存在的问题：

其次就是在代码上，要单独处理左边到边界处理右边和单独处理右边到边界。

![image-20250904151426260](C:\software-1\Typora\image\image-20250904151426260.png)

这个的思路从小的开始找，然后再填入数组中。另一个思路，就是用左右指针（因为是大的），从大的开始排序。

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> result;
        int n = nums.size();
        
        // 找到第一个非负数的位置（right）
        int right = 0;
        while (right < n && nums[right] < 0) {
            right++;
        }
        int left = right - 1; // left 指向最后一个负数

        // 用双指针合并左右两边的平方值（从最小平方开始）
        for (int i = 0; i < n; i++) {
            // 情况1: 左边已用完（left < 0），只处理右边
            if (left < 0) {
                result.push_back(nums[right] * nums[right]);
                right++;
            }
            // 情况2: 右边已用完（right >= n），只处理左边
            else if (right >= n) {
                result.push_back(nums[left] * nums[left]);
                left--;
            }
            // 情况3: 两边都有元素，比较平方值
            else {
                long left_sq = (long)nums[left] * nums[left];
                long right_sq = (long)nums[right] * nums[right];
                if (left_sq < right_sq) {
                    result.push_back(left_sq);
                    left--;
                } else {
                    result.push_back(right_sq);
                    right++;
                }
            }
        }
        return result;
    }
};
```



c**代码：**

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* sortedSquares(int* nums, int numsSize, int* returnSize) {
    int left=0,right=numsSize-1;

    int *res=(int *)malloc(sizeof(int)*numsSize);
    *returnSize = numsSize;
    for(int i=0,j=numsSize-1;i<=j;)
    {
        //左边的大于右边
        if(nums[i]*nums[i]>nums[j]*nums[j])
        {
            res[right--]=nums[i]*nums[i];
            i++;
        }
        else//右边大
        {
            res[right--]=nums[j]*nums[j];
            j--;
        }
    }
    return res;
}
```

c++:

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums)
    {
        vector<int> res(nums.size(),0); //初始化动态数组
        int left=0,right=nums.size()-1;
        int result=right;
        double doul;
        double dour;
    
        for(int i=0;i<nums.size();i++)
        {
            doul=nums[left]*nums[left];
            dour=nums[right]*nums[right];

            if(doul>dour)
            {
                res[result]=doul;
                result--;
                left++;
            }
            else
            {
                res[result]=dour;
                result--;
                right--;
            }
        }
        return nums;
    }
};
```



## 四、长度最小的子数组

**题目：**

![image-20240905200733716](C:\software-1\Typora\image\image-20240905200733716.png)

**分析：**

首先这个题目需要用到滑动窗口去记录一段区间内的数组的大小。其中这个窗口的区间使用快慢指针来记录。

1.对整个数组进行遍历，并且记录遍历数组之和。

2.在记录的数组中如果这个数组的区间大于目标值，就要进行处理

3.记录即可窗口的大小；对比每次窗口的大小，纪录最小的窗口；缩短左边的窗口，并且更新累加的值。

```c++
int minSubArrayLen(int target, vector<int>& nums)
    {
        int CurLen=INT32_MAX;
        int SubLen=0;
        int slow=0;
        int fast=0;
        int sum=0;

        for(fast=0;fast<nums.size();fast++)
        {
            sum=nums[fast]+sum;
            while(sum>=target)
            {
                SubLen=fast-slow+1;
                CurLen=SubLen<CurLen? SubLen:CurLen;
                sum=sum-nums[slow];
                slow++;
            }
        }
        return CurLen==INT32_MAX? 0:CurLen;
    }
```



## 五、螺旋矩阵

**题目：**

![image-20240905204018386](C:\software-1\Typora\image\image-20240905204018386.png)

分析：这道题不涉及具体的算法，就是模拟处理，一行一列的分析，但是其中要注意的就是在处理行列的时候，要注意偏移量的设置。

1.一行一列的进行分析，保证每行每列涉及到的数组是相等的。同时设置对应需要用到的变量。

2.其中涉及的一个变量是每一圈开始的位置，即这个环形的对角线的位置，从（0,0）（1,1）开始一直到最后。结束位置就是n,但是每一圈的开始和结束的位置都会进行一定的偏移，因此需要设置一个偏移的变量来进行每一圈最后一个位置的设定。

3.其次就是圈数的计算就是对n/2的操作来进行，同时对于奇数圈同样的方法可以得到中间值的索引值。

**代码：**

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n)
    {
        vector<vector<int>> res(n,vector<int>(n,0)); //定义一个二维数组

        int startx=0,starty=0;
        int loop=n/2;
        int mid=n/2;
        int count=1;
        int offset=1;
        int i,j;

        //圈数
        while(loop--)
        {
            i=startx;
            j=starty;

            //模拟每一行和列的处理

            //左到右 竖的数变化 竖的数最大
            for (j; j < n - offset; j++) 
            {
                res[i][j]=count++;
            }
            //上到下 横的数发生变化 横最大
            for(;i<n-offset;i++)
            {
                res[i][j]=count++;
            }

            //右导左 竖要变化
            for(;j>starty;j--)
            {
                res[i][j]=count++;
            }

            //上到下
            for(;i>startx;i--)
            {
                res[i][j]=count++;
            }

            //更新第二圈的初始位置 即对角线的位置 （1,1） （2，2）..。
            startx++;
            starty++;

            //更新偏移量
            offset+=1;
        }
        if(n%2==1)//如果圈数是奇数，就要对中间那个进行单独取模。
        {
            res[mid][mid]=count;
        }
    return res;
    }
};
```

**补充知识：**

定义一个动态数组可以使用vector,其中vector的定义如下：

```c++
vector<typename> name;

//typename是任何基本的类型，例如简单的数据类型，int，double,结构体。同时也可以是STL容器的类型，例如set,queue,vector。
//name后面一般包括要初始化这个类型的大小以及初始化的数值是多少。

```

