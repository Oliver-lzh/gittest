## 一、用栈模拟队列

### 1.题目

![image-20241021105118314](C:\software-1\Typora\image\image-20241021105118314.png)

### 2.遇到问题

Q1:

由于栈先进后出和队列先进线出的理念不一样，在进行出栈操作的时候，不能理解如何处理。查询资料和学习，得到可以使用2个栈来实现这个操作，一个出口在左用于存储，一个调转出口（在右边），由此和队列的出口一致得到解决。

### 3.题目分析

这道题就是运用2个栈对其进行队列的操作。

### 4.代码解答

```c++
class MyQueue {
public:
    stack<int> stIn;
    stack<int> stOut;

    MyQueue() {
     
    }
    
    void push(int x)
    {
        stIn.push(x);    
    }
    
    int pop()
    {
        if(stOut.empty())
        {
            while(!stIn.empty())
            {
                stOut.push(stIn.top());
                stIn.pop();
            }
        }    
        int result=stOut.top();
        stOut.pop();
        return result;
    }
    
    int peek()
    {
        int result=this->pop();
        stOut.push(result);
        return result;    
    }
    
    bool empty()
    {
        return stIn.empty()&&stOut.empty();    
    }
};


```

## 二、用队列实现栈

### 1.题目

![image-20241026114611067](C:\software-1\Typora\image\image-20241026114611067.png)

### 2.遇到问题

了解到可以通过一个队列来讲元素往后操作来实现，代码部分没有思路。

### 3.题目分析

思路就是将需要弹出的元素后的所有元素先全部重新入当前队列（除了最后一个），然后弹出。目的是不打乱原始的顺序

### 4.代码

```c++
class MyStack {
public:
    queue<int> que;

    MyStack() {

    }

    void push(int x) {
        que.push(x);
    }

    //思路就是将需要弹出的元素后的所有元素先全部重新入当前队列（除了最后一个），然后弹出。目的是不打乱原始的顺序
    int pop()
    {
        //将需要弹出的元素前面的元素往后面备份，之后弹出需要的
        int size = que.size();
        size--;
        while (size--)
        {
            //在后面添加一个最前面的元素，然后将最前面的元素删除（pop操作）
            que.push(que.front());
            que.pop();
        }
        int result = que.front();
        que.pop();
        return result;


        int size = que.size();
        size--;
        while (size--)
        {
            que.push(que.front());
            que.pop();
        }
        int result = que.front();
        que.pop();
        return result;
    }

    int top()
    {
        int size = que.size();
        size--;
        while (size--)
        {
            que.push(que.front());
            que.pop();
        }
        int result = que.front();
        //为了保证原始的队列的顺序是一样的
        que.push(que.front());
        que.pop();
        return result;
    }

    bool empty()
    {
        return que.empty();
    }
};


```



## 三、有效的括号

### 1.题目

![image-20241028200158156](C:\software-1\Typora\image\image-20241028200158156.png)

### 2.遇到问题

**Q1尝试解答**

通过存储前一半的符号的相反的括号后（入栈操作），然后进行后面出栈和后半部分进行比对是否一样来确定匹配。出现的问题就是不能完全解决全部出现的情况。这里也利用了栈的结构特点，所以比较适合做匹配类的题目。具体代码如下：

```c++
class Solution {
public:
    bool isValid(string s)
    {
        stack<char> Input;
        if(s.size()%2!=0)
        {
            return false;
        }

        int size=s.size();
        for(int i=0;i<size/2;i++)
        {
            if(s[i]=='(')       Input.push(')'); 
            else if(s[i]==')')  Input.push('(');

            else if(s[i]=='{')  Input.push('}');
            else if(s[i]=='}')  Input.push('{');
            
            else if(s[i]=='[')  Input.push(']');
            else if(s[i]==']')  Input.push('[');
        }

        for(int i=size/2;i<size;i++)
        {
            char result=Input.top();
            if(s[i]!=result)
            {
                return false;
            }
            else
            {
                Input.pop();
            }
        }

        return Input.empty();
    }
};
```

### 3.题目分析

首先，在自己做题使用所有括号都进行去反入栈后进行前后部分的比对中，明显出现没有考虑完全的情况，同时考虑到栈用来解决匹配问题，因此可以将全部去反，操作为左括号进行去反去和原来的比对，分析栈是否空和后续比对是否一致来判断这个括号对是否匹配这一操作。

分情况分析：

![image-20241028202029218](C:\software-1\Typora\image\image-20241028202029218.png)

### 4.代码解答

```c++
class Solution {
public:
    bool isValid(string s)
    {
        //不是偶数不成对，因此无法实现。
        if(s.size()%2!=0) return false;
        stack<char> st;

        for(int i=0;i<s.size();i++)
        {
            if(s[i]=='(')       st.push(')');
            else if(s[i]=='{')  st.push('}');
            else if(s[i]=='[')  st.push(']');

            //栈不为空的情况，就是左侧多余了括号 括号的类型不匹配
            else if(st.empty() || st.top()!=s[i]) return false;
            else st.pop();//这里就是栈的元素和遍历后面的相同，出现出栈操作
        }
        return st.empty();  
    }
};
```



## 四.删除字符串中的所有相邻重复性

### 1.题目

![image-20241204102210042](C:\software-1\Typora\image\image-20241204102210042.png)

### 2.遇到的问题

1.一开始想要采用栈进行元素的入栈后，如果有重复项，删除后然后再重新遍历开始一样的操作直到没有相邻重复项开始。但是发现这样的操作过于复杂，没有直接利用到栈的特性。

2.知道如何利用栈的特点契合这个题解决问题后，对于第一个元素的判断和入栈不明确，如下

```
for
{
	st.push(s[i]);
	if(st.top()==s[i])
		pop();
}
```

正确的操作思路应当如下：

- 先进行栈是否为空和是否顶层和当前元素不一样再入栈
- 一样就顶层进行出栈



### 3.题目分析

1.利用栈进行找出没有相邻重复项的字符串

2.利用一个循环将栈中的元素导出到一个string中

3.利用reverse函数将字符串的元素调转过来



### 4.代码

```c++
class Solution {
public:
    string removeDuplicates(string s) 
    {
        stack<char> st;
       
        //找到不重复的字符串
        for(int i=0;i<s.size();i++)
        {
           
            if(st.empty() || st.top()!=s[i])
            {
                st.push(s[i]);
            }
            else
            {
                st.pop();
            }
        }

        //不重复字符串从栈中提取然后输出
        string result="";
        while(!st.empty())
        {
            result+=st.top();
            st.pop();
        }
        //反转字符串
        reverse(result.begin(),result.end());
        return result;
    }
};
```

**注意：if(st.empty() || st.top()!=s[i]) 这个判断条件里面的不能相反，要进行是否为空后再判断不等于，就是为了让第一个元素成功入栈。**





## 5.逆波兰表达式求值

### 1.题目

![image-20241205171200658](C:\software-1\Typora\image\image-20241205171200658.png)

![image-20241205171212780](C:\software-1\Typora\image\image-20241205171212780.png)



### 2.遇到问题

对于本题，一开始的思路是正确的，就是使用栈来进行操作。将每一个数就行入栈后，如果遇到有符号，就将符号后面的2个数进行运算后，再将结果入栈，反复这个过程，直至最后一个元素。

1.vector<string>& tokens 这个类型一开始没有看明白是什么意思。其实就是定义了一个‘数组’的容器，数组的每一个元素的成分是字符串。

2.因为给出的是这样的形式![image-20241205171837752](C:\software-1\Typora\image\image-20241205171837752.png)，因此在判断是否是符号的时候是这样判断

```
 if(tokens[i]=="+" || tokens[i]=="-" || tokens[i]=="*" || tokens[i]=="/")
```

用的是“”双引号，区别于字符的单引号。

3.使用了如下的语句进行判断，错误点就在于else后面是不用跟判断语句的。

```c++
if(tokens[i]=="+")      st.push(num2+num1);
 else if(tokens[i]=="-")      st.push(num2-num1);
 else if(tokens[i]=="*")      st.push(num2*num1);
 else(tokens[i]=="/")      st.push(num2/num1);
```

正确的如下：

```c++
 if(tokens[i]=="+")           st.push(num2+num1);
 else if(tokens[i]=="-")      st.push(num2-num1);
  else if(tokens[i]=="*")      st.push(num2*num1);
  else                         st.push(num2/num1);
```

### 3.题目分析

- 首先就是进行元素的入栈操作
- 如果遇到有运算相关的字符，就进行栈顶2个元素的出栈和运算

### 4.代码解答

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens)
    {
        stack<long long> st;
        for(int i=0;i<tokens.size();i++)
        {
            if(tokens[i]=="+" || tokens[i]=="-" || tokens[i]=="*" || tokens[i]=="/")
            {
                long long num1=st.top();
                st.pop();
                long long num2=st.top();
                st.pop();

            

                if(tokens[i]=="+")           st.push(num2+num1);
                else if(tokens[i]=="-")      st.push(num2-num1);
                else if(tokens[i]=="*")      st.push(num2*num1);
                else                         st.push(num2/num1);
            }
            else
            {
                st.push(stoll(tokens[i]));
            }
        }
        int result=st.top();
        return result;
    }
};
```

