



# 树

## 一、前序遍历

### 1.题目

![image-20250303110326616](C:\software-1\Typora\image\image-20250303110326616.png)

### 2.遇到问题

开始不知道用哪种方法进行解决，查看讲解后知道可以用递归和栈的迭代的方法来做这道题，属于是开始完全没有什么思路的题。



### 3.思路

前序遍历的顺序是中左右，同时用栈的操作是先进后出，因此在入栈的顺序的时候，要先入栈右边再左边，而中间正常的入栈后出栈的操作就行。

- 保存最顶层的节点后，出栈，再将其节点的值存入数组
- 入栈右节点，再入栈左节点
- 在while循环中判断只要栈不为空就一直处理

### 4.题解

```c++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root)
    {
        //迭代法
        stack<TreeNode *> st;
        vector<int> result;
        if(root==NULL) return result;

        st.push(root);
        while(!st.empty())
        {
            TreeNode * node=st.top();//最顶的指针
            st.pop();
            result.push_back(node->val);
            if(node->right) st.push(node->right);
            if(node->left)  st.push(node->left);
        }
        return result;
    }
};
```







## 一、后序遍历

### 1.题目

![image-20250303114406642](C:\software-1\Typora\image\image-20250303114406642.png)

### 2.遇到问题

在用迭代法做完前序遍历后，和他的区别就是辩论的时候和处理不是同一时间发生了，所以需要用一个指针去遍历然后再组处理。



### 3.思路

- 定义一个指针负责遍历到书的最底层，节点不为空时就一直深入到根，同时将完成入栈的操作
- 在遍历到没有节点时候，就去找栈里面要元素，处理玩指向右边

### 4.题解

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root)
    {
        vector<int> result;
        stack<TreeNode *> st;
        TreeNode *cur=root;
        while(cur !=NULL !st.empty())
        {
            //空就弹出元素然后处理。
            if(cur !=NULL)
            {
                st.push(cur);
                cur=cur->left;
            }
            else
            {
                cur=st.top();
                st.pop();
                result.push_back(cur->val);
                cur=cur->right;
            }
          
        }
        return result;
    }
};
```

###  5.boolean 标记法

主要思想为：加一个 `boolean` 值跟随每个节点，`false` (默认值) 表示需要为该节点和它的左右儿子安排在栈中的位次，`true` 表示该节点的位次之前已经安排过了，可以收割节点了。则需要定义一个stack<pair<TreeNode*, bool>> st;的栈。

具体思路：

- 定义一个具有标记功能的栈的容器
- 在while中用智能指针记录顶层的信息
- 处理可以收割节点的操作
- 处理未能收割节点的操作  同时可以在这里修改为前中后序的代码，同时入栈顺序和排序是相反的顺序。

题解

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root)
    {
        //指针是空就去栈找元素，栈指向的中间 左中右
        vector<int> result;
        stack<pair<TreeNode *,bool>> st;
        TreeNode *cur=root;

        if(root !=nullptr)
            st.push(make_pair(root,false));//为其左右孩子安排位次

        while(!st.empty())
        {
            auto node=st.top().first;//智能指针指向树的节点
            auto visited=st.top().second; //指向是否安排位置的第二个值
            st.pop();

            if(visited) //表示该节点和2个孩子的位次已经安排了，现在可以处理这个节点了
            {
                result.push_back(node->val);
                continue;//继续从while开始 
            }

            //visited 当前为 false, 表示初次访问本节点，此次访问的目的是“把自己和两个儿子在栈中安排好位次”。

            //下面就是没有安排的时候的代码即visited为false
            //入栈就是 右中左
            if(node->right)
                st.push(make_pair(node->right,false));

            st.push(make_pair(node,true));

            if(node->left)
                st.push(make_pair(node->left,false));
        }
        return result;
    } 
};
```



### 6.NULL标记法

```c++
class Solution {
public:
    //传入引用是确保递归共享一个vector


    vector<int> preorderTraversal(TreeNode* root)
    {
        vector<int> result;
        stack<TreeNode *> st;
        if(root!=NULL) st.push(root);
        while(!st.empty())
        {
            TreeNode *node=st.top();
            if(node!=NULL)
            {
                st.pop();
                if(node->right) st.push(node->right);//右
                if(node->left)  st.push(node->left);//左
                st.push(node);//中
                st.push(NULL);
            }
            else
            {
                st.pop();
                node=st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
    return result;
    }
};
```





## 二、树的层序遍历

### 1.题目

![image-20250305112612550](C:\software-1\Typora\image\image-20250305112612550.png)

### 2.遇到问题

开始没有思路，看了讲解后是用到队列的方法来实现，但是对于每一层的处理不明白，最后看到的是用for循环的方式处理每一层。



### 3.思路

- 定义每一层队列的大小用来处理每一层树的结构
- 在for处理的时候，先处理前面的，然后按照左右的循序进行处理，最后将这一层存入结果。

### 4.题解

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) 
    {
        vector<vector<int>> result;    

        queue<TreeNode *> que;
        if(root!=NULL) que.push(root);
        
        while(!que.empty())
        {
            int size=que.size();
            vector<int> vec;

            for(int i=0;i<size;i++)
            {
                TreeNode *node=que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) qeu.push(node->right);

            }
            result.push_back(vec);
        }
        return result;
    }
};
```



## 三、右视图

### 1.题目

![image-20250317110437884](C:\software-1\Typora\image\image-20250317110437884.png)

### 2.遇到问题

第一次做的思路，不能完全通过，其思路如下：

1.按照之前一样直接先遍历，分情况分析各种情况，导致情况过多无法分析完全。看完答案后就是在原来的基础上只记录最后一个节点的最有一个元素。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root)
    {
        vector<int> result;   
        queue<TreeNode *> st;

        if(root!=NULL) st.push(root);

        while(!st.empty())
        {
            int sum=st.size();
            for(int i=0;i<sum;i++)
            {
                TreeNode *node=st.front();
                st.pop();
                result.push_back(node->val);
                if(node->left) st.push(node->left);
                else 
                {
                    if(node->right) 
                    {
                        result.push_back(node->right->val);
                    }
                }
                if(node->right) st.push(node->right);
            }
        }

        return result;
    }
};
```

### 3.思路

否遍历到单层的最后面的元素，如果是，就放进result数组中.

### 4.题解

```c++

class Solution {
public:
    vector<int> rightSideView(TreeNode* root)
    {
        vector<int> result;   
        queue<TreeNode *> st;

        if(root!=NULL) st.push(root);

        while(!st.empty())
        {
            int sum=st.size();
            for(int i=0;i<sum;i++)
            {
                TreeNode *node=st.front();
                st.pop();
                if(i==sum-1) result.push_back(node->val);
                if(node->left) st.push(node->left);
                if(node->right) st.push(node->right);
            }
        }

        return result;
    }
};
```









## 四、二叉树的层平均值

第一次做题：

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
    class Solution {
    public:
    vector<double> averageOfLevels(TreeNode* root)
    {
        vector<double> result;   
        queue<TreeNode *> st;
        if(root!=NULL) 
        {
            st.push(root);
            result.push_back(root->val);
        }

    ​    while(!st.empty())
    ​    {
    ​        long com=0;
    ​        int sum=st.size();
    ​        int average=0;
    ​        for(int i=0;i<sum;i++)
    ​        {
    ​            TreeNode *node=st.front();
    ​            com+=node->val;
    ​            st.pop();
    ​            if(node->left) st.push(node->left);
    ​            if(node->right) st.push(node->right);
    ​        }
    ​        result.push_back(com/sum);
    ​    }
    ​    return result;
    }

};



修改如下：

1.首节点不需要单独存放。

```c++
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root)
    {
        vector<double> result;   
        queue<TreeNode *> st;
        if(root!=NULL) 
        {
            st.push(root);
        }

        while(!st.empty())
        {
            double com=0;
            int sum=st.size();
            for(int i=0;i<sum;i++)
            {
                TreeNode *node=st.front();
                com+=node->val;
                st.pop();
                if(node->left) st.push(node->left);
                if(node->right) st.push(node->right);
            }
            result.push_back(com/sum);
        }
        return result;
    }

};
```







## 五、N叉树的层序遍历

- 1.node->children[i] 访问动态数组操作

- 2.查询动态数组个数 int size1=node->children.size();

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/


class Solution
{
public:
    vector<vector<int>> levelOrder(Node* root)
    {
        vector<vector<int>> result;
        queue<Node *> que;

        if(root!=NULL) que.push(root);

        while(!que.empty())
        {
            vector<int> rec;
            int size=que.size();
            for(int i=0;i<size;i++)
            {
                Node *node=que.front();
                que.pop();
                rec.push_back(node->val);
                int size1=node->children.size();
                for(int i=0;i<size1;i++)
                {
                    if(node->children[i]) que.push(node->children[i]);
                }
            }
            result.push_back(rec);
        }
        return result;
    }    
    
};
```



## 六、在每个树行中找最大值

max_elemant这个函数返回的是迭代器，因此需要用解引用。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> largestValues(TreeNode* root)
    {
        queue<TreeNode *> que;
        vector<int> result;

        if(root!=NULL) que.push(root);

        while(!que.empty())
        {
            int size=que.size();
            vector<int> ret;
            for(int i=0;i<size;i++)
            {
                TreeNode *node=que.front();
                que.pop();
                ret.push_back(node->val);

                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            result.push_back(*(max_element(ret.begin(),ret.end())));
        }    
        return result;
    }
};
```



## 七、填充每个节点的下一个右侧节点指针（1/2）



只不过在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点就可以了。



继续用root的原因。

该算法直接修改原始树中每个节点的 next 指针，不需要创建新节点 。原始 root 的指针仍然有效，且树的结构（left/right 指针）未被改变，只是增加了 next 连接。

```c++
class Solution {
public:
    Node* connect(Node* root)
    {
        queue<Node *> que;

        if(root!=NULL) que.push(root);

        while(!que.empty())
        {
            int size=que.size();
            Node *PreNode;
            Node *node;
            for(int i=0;i<size;i++)
            {
                if(i==0)
                {
                    PreNode=que.front();
                    que.pop();
                    node=PreNode;//保留当前这个节点，方便后续处理它的左右节点
                }
                else
                {
                    node=que.front();
                    que.pop();
                    PreNode->next=node;//前一个节点连接当前节点
                    PreNode=node;//当前节点更新为“前一个”节点为后续处理做准备
                }
                if(node->left)  que.push(node->left);
                if(node->right) que.push(node->right);
            }
            PreNode->next=NULL;
        }
        return root;
    }
};
```



第二次做：

```c++

class Solution {
public:
    Node* connect(Node* root)
    {
        queue<Node *> que;
        if(root!=NULL) que.push(root);
        while(!que.empty())
        {
            int size=que.size();
            for(int i=0;i<size;i++)
            {
                Node *node=que.front();
                que.pop();
                node->next=que.front();
                if(i==size-1)
                {
                    node->next=NULL;
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }    
        return root;
    }
};
```



## 八、最大深度

### 1.题目

![image-20250326101118248](C:\software-1\Typora\image\image-20250326101118248.png)

### 2.遇到问题

这个题目有2种做法，迭代法的层序遍历可以做这个题，没有无法理解的地方。第二中方法的递归有点难于理解，需要一层层的推理逻辑才能理解，同时知道了写递归的方法也难写出递归。



### 3.思路

在使用迭代法的时候就是在处理每一层进行+1处理。

在使用递归的方法的时候，可以使用左右中的后续求法来求深度。



```c++
递归法
class Solution {
public:
    int getdepth(TreeNode *node)
    {
        if(node==NULL)   return 0;
        int leftdep=getdepth(node->left);//左
        int rightdep=getdepth(node->right);//右
        int dep=max(leftdep,rightdep)+1;//中
        return dep;
    }
    int maxDepth(TreeNode* root)
    {
        return getdepth(root);
    }
};
```



```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root)
    {
        queue<TreeNode *> que;
        int result=0;

        if(root!=NULL) 
        {
            que.push(root);
            result++;
        }

        while(!que.empty())
        {
            int size=que.size();
            TreeNode *node;
            int flag=0;
            for(int i=0;i<size;i++)
            {
                node=que.front();
                que.pop();
                if(node->left)
                {
                    que.push(node->left);
                    flag=1;
                }
            

                if(node->right)
                {
                    que.push(node->right);
                    flag=1;
                } 
            }
            if(flag==1) result++;
        }
        return result;
    }
};
```



## 九、最小深度

### 1.题目

![image-20250326102349919](C:\software-1\Typora\image\image-20250326102349919.png)

### 2.遇到问题

对于最小深度的定义不是很理解，其意思就是从根节点到叶子节点的深度，其中这个叶子节点是没有左右子节点的。

![image-20250326102536145](C:\software-1\Typora\image\image-20250326102536145.png)

### 3.题解

在迭代法的方法中，加入左右为空就结束返回的操作即可。



尝试做：

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root)
    {
        queue<TreeNode *> que;
        int result=0;
        if(root!=NULL) 
        {
            que.push(root);
            result++;
        }
        else 
            return result;

        while(!que.empty())
        {
            int size=que.size();
            TreeNode *node;
            int flagleft=0;
            int flagright=0;
 
            for(int i=0;i<size;i++)
            {
                node=que.front();
                que.pop();
                
                //主要修改
                if (!node->left && !node->right) {
                    return result;
                }
                
                if(node->left)
                {
                    que.push(node->left);
                    flagleft=1;
                }
            
                if(node->right)
                {
                    que.push(node->right);
                    flagright=1;
                } 
            }
            if(flagleft ==1 || flagright==1) 
            {
                result++;
            }
            if(flagright==0 && flagleft==0)
            {
                break;
            }
                
        }
        return result;
    }

};
```



题解：

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root)
    {
        queue<TreeNode *> que;
        int result=0;
        if(!root) return result;
        que.push(root);
     
        while(!que.empty())
        {
            int size=que.size();
            TreeNode *node;
            result++;
            for(int i=0;i<size;i++)
            {
                node=que.front();
                que.pop();
                if(node->left)
                {
                    que.push(node->left);
                }
            
                if(node->right)
                {
                    que.push(node->right);
                   
                } 
                 if(!node->right && !node->left)
                {
                    return result;
                }
            }
              
                
        }
        return result;
    }

};



```



迭代法

```c++
class Solution {
public:
    int minDepth(TreeNode* root)
    {
        queue<TreeNode *> que;
        int result=0;
        if(root!=NULL) 
        {
            que.push(root);
        }
        else 
            return result;
        
        while(!que.empty())
        {
            int size=que.size();
            TreeNode *node;
            result++;
            for(int i=0;i<size;i++)
            {
                node=que.front();
                que.pop();
                if(node->left)
                {
                    que.push(node->left);
                }
                if(node->right)
                {
                    que.push(node->right);
                }
                if(!node->right && !node->left)
                    return result;
            }
            
        }
        return result;
    }

};
```



递归

```c++
class Solution {
public:

    int dep(TreeNode *node)
    {
        if(node==NULL) return 0;
        int leftdep=dep(node->left);
        int rightdep=dep(node->right);

        if(node->left && node->right==NULL)
            return 1+leftdep;

        if(node->left==NULL && node->right)
            return 1+rightdep;

        int result= 1+min(leftdep,rightdep);
        
        return result;
    }


    int minDepth(TreeNode* root)
    {
        return dep(root);
    }

};
```



## 十、对称二叉树

### 1.题目

![image-20250324103236145](C:\software-1\Typora\image\image-20250324103236145.png)



### 2.遇到问题

知道要怎么比较左右2边的元素，但是不知道用什么方法能够更好的比较，后面看了答案才知道啊可以用栈或者是队列其中的一个容器对其俩俩取出比较。



### 3.思路 

1.将左右节点存入队列

2.使用2个临时的变量来保存一对元素，方便后面相等或不同的比较

3.比较后，重新在这2个临时变量中按照顺序存入新的元素（从外侧->内侧）



### 4.题解

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) 
    {
        queue<TreeNode *> st;
        if(root==NULL) return true;
        st.push(root->left);
        st.push(root->right);

        while(!st.empty())
        {
            TreeNode *leftNode=que.front();que.pop();
            TreeNode *rightNode=que.front();que.pop();

            if(!leftNode && !rightNode)//说明是对称的
            {
                continue;
            }

            if(!leftNode || !rightNode || (left->val !=rightNode->val))
            {
                return false;
            }

            que.push(leftNode->left);
            que.push(rightNode->right);
            que.push(leftNode->right);
            que.push(rightNode->left);

        }
    return true;
    }
};
```



递归写法：

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
        bool compare(TreeNode *left,TreeNode *right)//第一步确定参数和返回值
        {
            //第二部确定返回条件
            if(left==NULL && right !=NULL) return false;
            else if(left !=NULL && right ==NULL) return false;
            else if(left==NULL && right == NULL) return true;
            else if(left->val != right->val) return false;

            //第三部.处理单层逻辑
            bool outside=compare(left->left,right->right);
            bool insize=compare(left->right,right->left);
            bool isSame=outside && insize;
            return isSame;
        }

    bool isSymmetric(TreeNode* root) 
    {
        if(root ==NULL) return true;
        return compare(root->left,root->right);
    }
};
```



衍生题目：

```c++
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q)
    {
        queue<TreeNode *>que;

        que.push(p);
        que.push(q);
        if(q==NULL && p==NULL)
        {
            return true;
        }
        if(q!=NULL && p==NULL)
            return false;
        if(p!=NULL && q==NULL)
            return false;

        while(!que.empty())
        {
            TreeNode *leftNode=que.front();
            que.pop();
            TreeNode *rightNode=que.front();
            que.pop();

            if(!leftNode && !rightNode)//表示左右都为空
                continue;//结束本次循环
            if(!leftNode || !rightNode || leftNode->val!=rightNode->val)//这里判断的是不对称的情况
                return false;
            //主要是这里修改了
            que.push(leftNode->left);
            que.push(rightNode->left);
            que.push(rightNode->right);
            que.push(leftNode->right);
      
        } 
        return true;
    }
};
```







## 十一、完全二叉树的节点个数

### 1、题目

![image-20250327105215207](C:\software-1\Typora\image\image-20250327105215207.png)



### 2.遇到问题

一开始用的是普通层序遍历的方法来计算节点的数量，后面发现没有利用的完全二叉树这个概念的特性。



### 3.思路

可以将一个完全二叉树分解为求各个分支上的满二叉树的思路来做，因为满二叉树只要知道深度就可以直接计算个数。其次在遇到非满二叉树的时候，可以对其进一步分解为满二叉树，然后通过递归返回上层的方法一次次进行计算。

一个重要概念就是左右子树相等的话，就是一个完全二叉树，可以用深度去求数量。

1.统计左子树节点和右子树节点

2.深度相等的情况下就计算树木

3.不相等就进入递归分批计算左右子树的数量。





### 4.题解

递归方法：

```c++
class Solution
{
public:
    int countNodes(TreeNode* root)
    {
        if(root==nullptr) return 0;
 
        TreeNode *left=root->left;
        TreeNode *right=root->right;
        int leftdep=0,rightdep=0;
        
        while(left)//求左边子树的深度
        {
            left=left->left;
            leftdep++;
        }

        while(right)
        {
            right=right->right;
            rightdep++;
        }

        if(leftdep==rightdep)
            return (2<<leftdep)-1;

        //左右不相等运行这个一层层递归统计
        int leftNum=countNodes(root->left);     //左
        int rightNum=countNodes(root->right);   //右
        int result=leftNum+rightNum+1;          //中

        return result;
    }
};
```



## 十二、平衡二叉树

### 1.题目

![image-20250403105332837](C:\software-1\Typora\image\image-20250403105332837.png)

### 2.遇到问题

对于深度和高度的定义不了解，导致不知道如何解题。深度可以理解为从根节点往下数叶子节点，而高度是从叶子节点从上面数到根节点。

![image-20250403105536721](C:\software-1\Typora\image\image-20250403105536721.png)

### 3.思路

使用递归法时候：

因为高度是从底层到上层一次次往上加，因此采用的遍历应当是后续遍历，即为左右中，这样就可以层层往上返回高度，而层度是从第一层开始累加因此采用的是中左右。

递归步骤：

- 明确递归函数的参数和返回值：  参数：传入一个节点  返回值：反应改节点的高度即为int
- 确定返回条件：遇到空节点就返回0
- 单层循环：统计左右子树的高度，判断是否节点就不是平衡；或者是返回高度



### 4.题解

```c++
递归
class Solution {
    public:
    
        int getheight(TreeNode *node)
        {
            if(node==NULL) return 0;
            int leftheight=getheight(node->left);
            if(leftheight==-1) return -1;
            int rightheight=getheight(node->right);
            if(rightheight==-1) return -1;
    
            int result;
            if(abs(leftheight-rightheight)>1)
                result=-1;
            else
                result=1+max(leftheight,rightheight);
    
            return result;
        }
    
        bool isBalanced(TreeNode* root)
        {
            return getheight(root)==-1? false : true;
        }
    };

```



一层层的左右节高度进行判断

```c++
 迭代法
 int getDepth(TreeNode *node)
    {
        stack<TreeNode *> st;
        if(node!=NULL) st.push(node);

        int depth=0;
        int result=0;
        while(!st.empty())
        {
            TreeNode *cur=stack.top();
            if(cur!=NULL)
            {
                st.pop();
                st.push(cur);
                st.push(NULL);//插入NULL表示这个节点已经被处理
                depth++;
                if(cur->right) st.push(node->right);
                if(cur->left)  st.push(node->left);
            }
            else
            {
                st.pop();
                node=st.top();
                st.pop();
                depth--;
            }
           result=result>depth? result:depth;
        }
        return result;
    }

    bool isBalanced(TreeNode* root)
    {
       stack<TreeNode *> st;
       if(root==NULL) return true;
       st.push(root);
       while(!st.empty())
       {
            TreeNode *node=st.top();
            st.pop();
            if(abs(getDepth(node->left)-getDepth(node->right))>1)
                return false;
            if(node->right) st.push(node->right);
            if(node->left)  st.push(node->left);
       }
    return true;
    }
};
```



## 十三、二叉树的所有路径

### 1.题目

![image-20250403210441201](C:\software-1\Typora\image\image-20250403210441201.png)



### 2.遇到问题

完全不知道思路，知道所有的路径但是代码上面不知道使用什么方法处理。



### 3.思路

- 首先，路径是从根节点到叶子节点的这样一个连接的顺序，因此前序遍历符合这样的思路
- 在处理递归的遍历的过程中，因为比如有些节点是要重复使用的，有些是要被抛弃的，因此需要使用回溯来舍弃一些节点，来重新连接一个新的路径。



递归流程：

1.递归的返回和输入参数

只需要拼接字符串，因此无返回值，为void。输入参数首先需要传入一个叶子节点，一个保存遍历过程中的所有元素，一个拼接返回最后的路径结果。

2.返回逻辑

遇到叶子节点就返回，同时在最后的叶子节点实现之前的所有拼接

3.单层逻辑

中左右的遍历顺序，同时在左右的时候回溯抛弃一些元素。

中的时候记录的是当前的数值，保存路径。



### 4.题解

```c++
class Solution {
public:

    void getpath(TreeNode *cur,vector<int> &path,vector<string> &result)
    {
        path.push_back(cur->val);//中
        if(cur->left==NULL && cur->right==NULL)
        {
            string sPath;
            for(int i=0;i<path.size()-1;i++)//将path记录的路径用string连接
            {
                sPath+=to_string(path[i]);
                sPath+="->"
            }
            //拼接最后一个叶子节点 因为最后一个节点不需要连接->符号
            sPath+=to_string(path[path.size()-1]);
            result.push_back(sPath);
            return;
        }
        if(cur->left)//左
        {
            getpath(cur->left,path,result);
            path.pop_back();
        }
        if(cur->right)//右
        {
            getpath(cur->right,path,result);
            path.pop_back();
        }
    }

    vector<string> binaryTreePaths(TreeNode* root)
    {
        vector<string> result;
        vector<int> path;
        if(root==NULL) return result;
        getpath(root,paht,result);
        return result;
    }
};
```



## 十四、左叶子之和

### 1.题目

![image-20250407110418332](C:\software-1\Typora\image\image-20250407110418332.png)

### 2.遇到问题

不清晰左叶子的定义，将其理解为左节点，导致错误，左叶子的定义为：**节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么A节点的左孩子为左叶子节点**

理解为左节点之后的写法。

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) 
    {
        vector<int> result;
        int result1;
        stack<TreeNode *> st;
        if(root!=NULL) st.push(root);
        while(!st.empty())
        {
            TreeNode *node=st.top();
            if(node!=NULL)
            {
                st.pop();
                if(node->right) st.push(node->right);//右
                if(node->left)  
                {
                    st.push(node->left);//左
                    result.push_back(node->left->val);
                }
                st.push(node);//中
                st.push(NULL);
            }
            else
            {
                st.pop();
                node=st.top();
                st.pop();
            }
        }
    result1=std::accumulate(result.begin(),result.end(),0);
    return result1;
    }
};
```



### 3.思路

迭代法：

- 在使用迭代法的时候，在遍历阶段将存在左叶子的元素统计起来。
- 判断依据为：(node->left!=NULL && node->left->left==NULL &&  node->left->right==NULL) 当前节点的左节点存在，左节点的左右孩子为空。

### 4.题解

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) 
    {
        vector<int> result;
        int result1;
        stack<TreeNode *> st;
        if(root!=NULL) st.push(root);
        while(!st.empty())
        {
            TreeNode *node=st.top();
            if(node!=NULL)
            {
                if(node->left!=NULL && node->left->left==NULL &&                
                node->left->right==NULL)
                {
                    result.push_back(node->left->val);
                }
                st.pop();
                if(node->right) st.push(node->right);//右
                if(node->left)   st.push(node->left);//左
                st.push(node);//中
                st.push(NULL);
            }
            else
            {
                st.pop();
                node=st.top();
                st.pop();
            }
        }
    result1=std::accumulate(result.begin(),result.end(),0);
    return result1;
    }
};
```



递归法

```c++
class Solution {
public:
    void scan(TreeNode *node,vector<int> &result)
    {
        if(node==NULL) return;
        if(node->left!=NULL && node->left->left==NULL &&                
            node->left->right==NULL)
        {
            result.push_back(node->left->val);
        }
        scan(node->left,result);
        scan(node->right,result);

    }
    int sumOfLeftLeaves(TreeNode* root) 
    {
        vector<int> result;
        int result1=0;
        scan(root,result);
        result1=std::accumulate(result.begin(),result.end(),0);
        return result1;
    }
};

```



## 十五、找树左下角的值

### 1.题目

![image-20250408110840263](C:\software-1\Typora\image\image-20250408110840263.png)



### 2.遇到问题

第一时间想到的就是层序遍历，要做的就是记录最后一层的第一次出现的元素，在代码的时候分成了2步，先遍历确定层数，再遍历用层数和第一次出现的元素记录数值，其实麻烦了，直接每次记录每层第一次出现的元素，到最后就是留下最后一层的元素。



### 3.思路

在层序遍历的时候加上记录第一次出现的元素。

```
if(i==0) reszult=node->val; //每次遍历每层的时候都会被重新赋值
```



### 4.题解

```c++
class Solution {
public:
    int findBottomLeftValue(TreeNode* root)
    {
        queue<TreeNode *> que;
        int reszult;
        int dep=0;
        int dep1=0;

        if(root!=NULL) que.push(root);

        while(!que.empty())
        {
            int size=que.size();
            for(int i=0;i<size;i++)
            {
                TreeNode *node=que.front();
                que.pop();
                if(i==0) reszult=node->val; //每次遍历每层的时候都会被重新赋值
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }           
        }

    return reszult;
    }
};
```



## 十六、路径总和

### 1.题目

![image-20250409114050605](C:\software-1\Typora\image\image-20250409114050605.png)

### 2.遇到问题

一开始想到的是层序遍历，主要问题是卡在如何在每一层只是记录那个需要的元素，因为每层的处理之前的代码都是通过for循环直接处理一层的。

问了AI之后，知道通过删除for循环来每一个处理。

### 3.思路

过删除for循环来每一个处理。

### 4.题解

```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum)
    {
        if(root==NULL) return false;

        queue<pair<TreeNode *,int>> q;
        q.push({root,root->val});

        while(!q.empty())
        {
            auto [node,current]=q.front();
            q.pop();

            if(node->left==NULL && node->right==NULL)
            {
                if(current==targetSum) return true;
            }
            else
            {
                if(node->left!=NULL) 
                {q.push({node->left,current+node->left->val});}
                if(node->right!=NULL) 
                {q.push({node->right,current+node->right->val});}
            }
        }
        return false;    
    }
};
```





## 十七、从中序与后序遍历序列构造二叉树

### 1.题目

![image-20250411161519293](C:\software-1\Typora\image\image-20250411161519293.png)

### 2.遇到问题

思路上不知道如何解决。在看讲解的视频后，知道了思路就是通过后续确定中间后，再在中序遍历进行切割，切割后再一直切割，知道分析出全部。知道了思路，代码上不知道怎么样书写。

### 3.思路

1.确定递归函数的参数：需要返回的是一个树的叶子节点，传入中序和后续数组进行遍历。

2.确定返回条件：当中序数组的节点被切割到1的时候就可以返回这个节点信息。

3,.单层逻辑：

- 找到后序数组的最后一个元素作为切割节点
- 在中序数组中找到该节点后作为切割节点
- 切割中序数组，切割后续数组
- 传入递归逻辑 

### 4.题解

```c++
class Solution {
private:
    TreeNode* traversal(vector<int>& inorder, vector<int>& postorder)
        {
            if(postorder.size()==0) return NULL;

            int rootvalue=postorder[postorder.size()-1];
            TreeNode *root=new TreeNode(rootvalue);
            if(inorder.size()==1)
            {
                return root;
            }

            int middle;
            for(middle=0;middle<inorder.size();middle++)
            {
                if(inorder[middle]==rootvalue) break;
            }

            //切割中序数组
            vector<int> leftInorder(inorder.begin(),inorder.begin()+middle);
            vector<int> rightInorder(inorder.begin()+middle+1,inorder.end());

            postorder.resize(postorder.size()-1);

            //切割后续数组
            vector<int> leftPostorder(postorder.begin(),postorder.begin()+leftInorder.size());
            vector<int> rightPostorder(postorder.begin() + leftInorder.size(),postorder.end());

            root->left=traversal(leftInorder,leftPostorder);
            root->right=traversal(rightInorder,rightPostorder);

            return root;

        }

public:

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder)
    {
        if(inorder.size()==0 || postorder.size()==0) return NULL;
        return traversal(inorder,postorder);
    }
};
```





中序和前序遍历

```
class Solution {
public:
    TreeNode* travel(vector<int>& preorder, vector<int>& inorder)
    {
        if(preorder.size() == 0) return NULL;

        int rootValue = preorder.front(); // 修正根节点值的获取
        TreeNode *root = new TreeNode(rootValue);

        if(inorder.size() == 1) return root;

        int middle = 0;
        for(; middle < inorder.size(); middle++)
        {
            if(inorder[middle] == rootValue) break;
        }

        // 切割中序数组
        vector<int> leftInorder(inorder.begin(), inorder.begin() + middle);
        vector<int> rightInorder(inorder.begin() + middle + 1, inorder.end());

        // 剔除前序遍历的首个元素
        preorder.erase(preorder.begin());

        // 切割前序数组
        vector<int> leftPreorder(preorder.begin(), preorder.begin() + leftInorder.size());
        vector<int> rightPreorder(preorder.begin() + leftInorder.size(), preorder.end()); // 修正分割右前序的范围

        root->left = travel(leftPreorder, leftInorder);
        root->right = travel(rightPreorder, rightInorder);

        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder)
    {
        if(preorder.size() == 0 || inorder.size() == 0) return NULL;
        return travel(preorder, inorder);
    }
};
```

![image-20250412201016091](C:\software-1\Typora\image\image-20250412201016091.png)



## 十八、最大二叉树

### 1.题目

![image-20250415093901083](C:\software-1\Typora\image\image-20250415093901083.png)



### 2.遇到问题

思路是正确的，但是代码上有一些小错误和处理的不够明确。

1.获取数组中最大值不正确，记住max_element()这个函数，返回的是迭代器指针位置，取值需要用*。

2.在分割数组的时候，考虑的太多，没用想到用索引位置来解决分割问题，应该熟悉获取索引的函数

```
int maxIndex = distance(nums.begin(), maxIt);//从起始位置到最大值maxit的距离，即最大值的索引位置
```

考虑的太细的情况：

![image-20250415094205915](C:\software-1\Typora\image\image-20250415094205915.png)



### 3.思路

1.获取最大值和最大值的索引。

2.根据最大值创建节点，根据最大值的索引进行分割处理。

补充一个知识点就是，vector创建的数组是一个左闭右开的区间[)，是不包含右边的数据的，如

```
vector<int> left(nums.begin(), nums.begin() + maxIndex);
```

就是不包含最大值，而是他的左边，其次[star,star)这个表示是一个空数组。

nums.end()他包含数组的最后一个元素，因为它不是指向最后一个数组的位置，而是最后一个元素的后一个位置。

### 4.题解

```c++
class Solution {

private:
    TreeNode* buildTree(vector<int>& nums) 
    {
        if (nums.empty()) return nullptr;

        // 找到最大值及其索引
        auto maxIt = max_element(nums.begin(), nums.end());//找到最大值的迭代器位置
        int maxIndex = distance(nums.begin(), maxIt);//从起始位置到最大值maxit的距离，即最大值的索引位置
        int maxValue = *maxIt;//最大值

        // 创建根节点
        TreeNode* root = new TreeNode(maxValue);

        // 递归终止条件
        if (nums.size() == 1) return root;

        // 分割左右子数组 已经剔除了最大元素
        vector<int> left(nums.begin(), nums.begin() + maxIndex);
        vector<int> right(nums.begin() + maxIndex + 1, nums.end());

        // 递归构建左右子树
        root->left = buildTree(left);
        root->right = buildTree(right);

        return root;
    }

public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums)
    {
        if (nums.empty()) return nullptr;
        return buildTree(nums);
    }
};
```





## 十九、合并二叉树

### 1.题目

![image-20250426162226511](C:\software-1\Typora\image\image-20250426162226511.png)

### 2.遇到问题

使用递归的时候，核心的逻辑不知道写在哪里，应该是写在如前序遍历中的，中处理的逻辑就是加。

### 3.思路

- 在前序遍历的基础上，加上一个中的相加操作。

### 4.题解



递归法：

```c++
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2)
    {
        if(root1==NULL) return root2;//某一个树是空就返回另一颗树
        if(root2==NULL) return root1;

        TreeNode *root=new TreeNode(0);

        root->val=root1->val+root2->val;
        root->left=mergeTrees(root1->left,root2->left);
        root->right=mergeTrees(root1->right,root2->right);
        return root;
    }
};
```



迭代法：

```c++
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2)
    {
        if(root1==NULL) return root2;
        if(root2==NULL) return root1;

        queue<TreeNode *> que;
        que.push(root1);
        que.push(root2);

        while(!que.empty())
        {
            TreeNode *node1=que.front();
            que.pop();
            TreeNode *node2=que.front();
            que.pop();

            node1->val+=node2->val;

            //左右不为空就加入到队列
            if(node1->left !=NULL && node2->left!=NULL)
            {
                que.push(node1->left);
                que.push(node2->left);
            }

            if(node1->right !=NULL && node2->right!=NULL)
            {
                que.push(node1->right);
                que.push(node2->right);
            } 

            if(node1->left ==NULL && node2->left!=NULL)
            {
                node1->left=node2->left;
            }

            if(node1->right ==NULL && node2->right!=NULL)
            {
                node1->right=node2->right;
            }
        }
    return root1;
    }
};
```





## 二十、二叉搜索树中的搜索

### 1.题目

![image-20250429103605280](C:\software-1\Typora\image\image-20250429103605280.png)

### 2.遇到问题

开始以为找到这个节点后，要怎么想办法将这个找到值的节点的树怎么样构建起来。看了之后发现，只要找到这个节点返回这个指针就可以了，不需要重新构建。

### 3.思路

主要的思维就是遍历，但是要利用二叉搜索树的特性，左边的值比节点小，右边的值比节点大。因此在递归的时候，只要加入大小的判断减少递归次数即可。

### 4.题解

```c++
class Solution {
public:

    TreeNode* searchBST(TreeNode* root, int val)
    {
        if(root==NULL) return NULL;
        TreeNode* result = NULL;
        if(root->val==val) return root;
        if(root->val>val) result=searchBST(root->left,val);
        if(root->val<val) result=searchBST(root->right,val);

        return result;
    }
};
```





## 二十一、验证二叉搜索树

### 1.题目

![image-20250803111229928](C:\software-1\Typora\image\image-20250803111229928.png)

### 2.遇到问题

1.一开始的思路就是遍历一个节点然后判断左右节点是否符合左小右大的条件，然后再回溯处理各个节点的。但是错误就是要比较的是节点和整个子树的关系。像下面这中情况就会出现错误。

![image-20250803111441562](C:\software-1\Typora\image\image-20250803111441562.png)

### 3.思路

数组法：按照中序遍历后，如果是一个二叉搜索树，那么里面的元素就会顺序排列，以此来验证是否为二叉搜索树。



### 4.题解

递归：

```c++
class Solution {

public:
    long long maxVal=LONG_MIN;
    bool isValidBST(TreeNode* root)
    {
       if(root==NULL) return true;

       bool left=isValidBST(root->left);
       if(maxVal<root->val) maxVal=root->val;
       else return false;
       bool right=isValidBST(root->right);

       return left && right;
    }
};
```



# 二十二、二叉搜索树的最小绝对差

### 1.题目

![image-20250803154859578](C:\software-1\Typora\image\image-20250803154859578.png)

### 2.遇到问题

1.一开始以为从小到大排序后，以为第一个元素和第二个元素的差值最小，实际是都要比较。



### 3.思路

数组法：将元素利用递归进行排序后形成一个数组，然后再计算各个元素之间的差值。



### 4.题解

数组法

```c++
class Solution {
private:
    vector<int> vec;
    void travel(TreeNode *root)
    {
        if(root==NULL) return;
        travel(root->left);
        vec.push_back(root->val);
        travel(root->right);
    }
public:
    int getMinimumDifference(TreeNode* root)
    {
        
        vec.clear();
        travel(root);
        if(vec.size()<2) return 0;
        int result=INT_MAX;
        for(int i=1;i<vec.size();i++)
        {
            result=min(result,vec[i]-vec[i-1]);
        }
        return result;
    }
};
```



递归法

```c++
class Solution
{
private:
int result=INT_MAX;
TreeNode *pre=NULL;
void travel(TreeNode *root)
{
    if(root==NULL) return ;
    travel(root->left);
    if(pre!=NULL)
    {
        result=min(result,root->val-pre->val);
    }
    pre=root;
    travel(root->right);
}
    
public:
    int getMinimumDifference(TreeNode* root)
    {
        travel(root);
        return result;
    }
       
};
```





## 二十三、二叉搜索树中的众数

### 1.题目

![image-20250803164107302](C:\software-1\Typora\image\image-20250803164107302.png)

### 2.遇到问题

1.不知道如何使用什么方法进行最大频率更新的问题，就是遍历后不知道怎么样更新最大频率的问题。

### 3.思路

1、利用中序遍历进行元素的遍历

2、对频率进行一个统计

3、处理频率出现的问题

### 4.题解

```c++
class Solution
{
private:
    int maxCount=0;//统计出现的频率
    int count=0;//统计频率
    TreeNode *pre=NULL;
    vector<int> result;
    void searchBST(TreeNode *cur)
    {
        if(cur==NULL) return ;
        searchBST(cur->left);

        if(pre==NULL) count=1;
        else if(pre->val == cur->val)
            count++;
        else
            count=1;
        pre=cur;

        if(count==maxCount)
            result.push_back(cur->val);
        
        if(count>maxCount)
        {
            maxCount=count;
            result.clear();//之前用的逻辑更新的元素是不对的，因此进行删除
            result.push_back(cur->val);
        }

        searchBST(cur->right);
        return ;
    }

public:
    vector<int> findMode(TreeNode* root)
    {
        count=0;
        maxCount=0;
        pre=NULL;
        result.clear();

        searchBST(root);
        return result;
    }
};
```





## 二十四、二叉树的最近公共祖先

### 1.题目

![image-20250803172616534](C:\software-1\Typora\image\image-20250803172616534.png)

### 2.遇到问题

递归的精髓就是这个函数帮你完成了这个功能，你要如何去利用他。



### 3.思路



![image-20250803172748900](C:\software-1\Typora\image\image-20250803172748900.png)

### 4.题解



```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 
    {
        if(root==NULL)
            return NULL;
        if(root==p || root==q) 
            return root;

        TreeNode *left=lowestCommonAncestor(root->left,p,q);
        TreeNode *right=lowestCommonAncestor(root->right,p,q);

        if(left==NULL) return right;
        if(right==NULL) return left;

        if(left && right) 
            return root;
        return NULL;
    }
};
```



```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 
    {
        if(root==q || root==p || root==NULL) return root;
        TreeNode *left=lowestCommonAncestor(root->left,p,q);
        TreeNode *right=lowestCommonAncestor(root->right,p,q);

        if(left!=NULL && right!=NULL) return root;

        if(left==NULL && right==NULL) return NULL;
        else if(left==NULL && right!=NULL) return right;
        else return left;
    }
};
```





## 二十五、二叉搜索树的最近公共祖先

### 1.题目

![image-20250807165041063](C:\software-1\Typora\image\image-20250807165041063.png)

### 2.遇到问题

1.如何利用二叉搜索树这个特点去解决问题，其次就是如何处理代码的逻辑需要明确的就是：**当我们从上向下去递归遍历，第一次遇到 cur节点是数值在[q, p]区间中，那么cur就是 q和p的最近公共祖先。**

### 3.思路

1.如果当前val值比pq大，就遍历左子树（找小的）

1.如果当前val值比pq小，就遍历右子树（找大的）

### 4.题解

```c++
class Solution {
private:
    TreeNode *traversal(TreeNode *cur,TreeNode *p,TreeNode *q)
    {
        if(cur==NULL)   return cur;

        if(cur->val>p->val && cur->val>q->val)
        {
            TreeNode *left=traversal(cur->left,p,q);
            if(left!=NULL)
                return left;
        }

        if(cur->val < p->val && cur->val < q->val)
        {
            TreeNode *right=traversal(cur->right,p,q);
            if(right!=NULL)
                return right;
        }

        return cur;
    }
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)
    {
      return traversal(root,p,q);
    }
};
```







1.题目

2.遇到问题

3.思路

4.题解
