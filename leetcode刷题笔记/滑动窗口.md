# 算法结合

![image-20251021104311008](C:\software-1\Typora\image\image-20251021104311008.png)



## 滑动窗口

滑动窗口也可以理解为快慢指针的方法，其**主要是算法技巧是来来解决字数组的问题（普通数的数组和字符串类型的数组），比如去寻找某个符合最长/最短的子数组。**其主要的思维方法就是通过穷举这个方法来解决问题，但是这个穷举的方法是左右指针是不会退的聪明的穷举。



局部框架：

```c++
// 滑动窗口算法伪码框架
void slidingWindow(string s) {
    // 用合适的数据结构记录窗口中的数据，根据具体场景变通
    // 比如说，我想记录窗口中元素出现的次数，就用 map
    // 如果我想记录窗口中的元素和，就可以只用一个 int
    auto window = ...

    int left = 0, right = 0;
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        window.add(c);
        // 增大窗口
        right++;

        // 进行窗口内数据的一系列更新
        ...

        // *** debug 输出的位置 ***
        printf("window: [%d, %d)\n", left, right);
        // 注意在最终的解法代码中不要 print
        // 因为 IO 操作很耗时，可能导致超时

        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            window.remove(d);
            // 缩小窗口
            left++;

            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```

这个框架解决的主要是三个问题：

1、什么时候应该移动 right 扩大窗口（while什么条件下一直扩大窗口）？窗口加入字符时，应该更新哪些数据？

2、什么时候窗口应该暂停扩大，开始移动 left 缩小窗口？从窗口移出字符时，应该更新哪些数据？ 这一步是最关键，一般是可能的要求是求解这个子字符串的大小或者是利用valid记录这个字符串出现的需要的次数来缩小窗口。

3、什么时候应该更新结果？ 一般是在第二个while开始或者是整个while结束后。



### 固定窗口长度（入 更新出）

#### [1456. 定长子串中元音的最大数目 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

```c++
class Solution {
public:
    int maxVowels(string s, int k)
    {
        int left=0,right=0;
        int middle=0;
        int result=0;
        for(;right<s.size();right++)
        {
            if(s[right]=='a' || s[right]=='e' || s[right]=='i' || s[right]=='o' || s[right]=='u')
            {
                middle++;
            }
            if(right-left+1==k)
            {
                result=max(middle,result);
               if(s[left]=='a' || s[left]=='e' || s[left]=='i' || s[left]=='o' || s[left]=='u')
                {
                    middle--;
                }
                left++; 
            }
        }
        return result;
    }
};
```



#### [643. 子数组最大平均数 I - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-average-subarray-i/)

```c++
class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k)
    {
        int right=0,left=0;
        double result=INT_MIN;
        double middle=0;
        int sum=0;
        while(right<nums.size())
        {
            //滑动右窗口
            sum=sum+nums[right];
            right++;

            while(right-left==k)
            {
           
                //捕获结果
                middle=sum;
                result=max(middle,result);
                //滑动左窗口
                sum-=nums[left];
                left++;
            }

        }
        return result/k;
    }
}; 
```



#### [1343. 大小为 K 且平均值大于等于阈值的子数组数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/)

```c++
class Solution {
public:
    int numOfSubarrays(vector<int>& arr, int k, int threshold)
    {
        int left=0,right=0;
        int sum=0;
        int result=0;

        for(;right<arr.size();right++)
        {
            sum+=arr[right];
            if(right-left+1==k)
            {
                if(sum>=threshold*k)
                {
                    result++;
                }
                sum-=arr[left];
                left++;
            }
        }      
        return result;
    }
};
```



```c++
class Solution {
public:
    int numOfSubarrays(vector<int>& arr, int k, int threshold)
    {
        int left=0,right=0;
        int sum=0;
        int result=0;

        while(right<arr.size())
        {
            sum=sum+arr[right];
            right++;
            while(right-left==k)
            {
                if(sum>=threshold*k)
                {
                    result++;
                }
                sum-=arr[left];
                left++;
            }
        }
        return result;
    }
};
```

注意点：

- right++的时候应当先进行处理，不然先++会导致数组的越界
- 在求平均值的时候，尽量不要使用除法，因为除于得到2.5的数会被处理成2.



#### [2090. 半径为 k 的子数组平均值 - 力扣（LeetCode）](https://leetcode.cn/problems/k-radius-subarray-averages/description/)#



```c++
class Solution {
public:
    vector<int> getAverages(vector<int>& nums, int k)
    {
        int n = nums.size();
        vector<int> result(n, -1); // ✅ 初始化全为 -1，长度固定

        if(k * 2 + 1 > n)
        {
            return result;
        }

        long long sum = 0; // 防止溢出
        int left = 0;
        int right = 0;

        while(right < n)
        {
            sum += nums[right];
            right++;

            if(right - left == k * 2 + 1)
            {
                int average = sum / (k * 2 + 1);
                result[left + k] = average; // ✅ 关键：平均值应该填在中心位置 left + k
                sum -= nums[left];
                left++;
            }
            // 不再 push_back，因为 result 已经初始化好了
        }

        return result;
    }
};
```

使用初始化为-1来优化算法。

```c++
class Solution {
public:
    vector<int> getAverages(vector<int>& nums, int k)
    {
        int left=0;
        int right=0;
        int average=0;
        int sum=0;
        vector<int> result;

        if(k*2+1>nums.size())
        {
            for(int i=0;i<nums.size();i++)
            {
                result.push_back(-1);
            }
            return result;
        }    

        while(right<nums.size())
        {
            sum+=nums[right];
            right++;

            if(right-left==k*2+1)
            {
                average=sum/(k*2+1);
                result.push_back(average);
                sum-=nums[left];
                left++;
            }
            else//这种方式就是想一步步的初始化，在需要的时候初始化为1，但是后续几个难处理
            {
                result.push_back(-1);
            }
        }

 
        return result;
    }
};
```

这个思路是直接-1和对应的值一起填充的。

第一次重做

```c++
class Solution {
public:
    vector<int> getAverages(vector<int>& nums, int k)
    {
        int right=0,left=0;
        vector<int> result(nums.size(), -1);
        long long middle=0;

        for(;right<nums.size();right++)
        {
            middle+=nums[right];
            if(right-left+1==2*k+1)
            {
                result[left+k]=middle/(2*k+1);
                middle-=nums[left];
                left++;
            } 
        }
        return result;
    }
};
```

错误点分析：

初始化为负1

```
        vector<int> result=-1; //错误方式

```

惯性思维窗口的收缩就在当前的right，但是这题是使用半径，所以窗口的范围是双倍的

```
   if(right-left+1==2*k+1)
```



#### [2379. 得到 K 个黑块的最少涂色次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/)

```c++
class Solution {
public:
    int minimumRecolors(string blocks, int k)
    {
        int left=0,right=0;
        int result=INT_MAX;
        int middle=0;

        while(right<blocks.size())
        {
            if(blocks[right]=='W')
            {
                middle++;
            }
            right++;
            if(right-left==k)
            {
                result=min(middle,result);
                if(blocks[left]=='W')
                {
                    middle--;
                }
                left++;               
            }
        }
        return result;
    }
};
```

这道题关键点在于，在更新左边窗口的时候，他是没有条件也要移动。



```c++
class Solution {
public:
    long long maximumSubarraySum(vector<int>& nums, int k)
    {
        int left=0,right=0;
        int middle=0;
        int result=INT_MIN;
        while(right<nums.size())
        {
            middle+=nums[right];
            right++;
            if(nums[right]==nums[right-1])
            {
                left=right;
                middle-=nums[right-1];

            }
            if(right-left==k)
            {
                result=max(middle,result);
                middle-=nums[left];
                left++;
            }
        }    
    }
};
```

这是一开始的做法：想要在有窗口划入的时候就清除重复元素，但是因为重复的位置以及k的大小不确定导致逻辑不好做，我目前写的只是考虑一种情况。

还有一开始的做法是想全部加进来再在结果出去重发现页比较难做。



#### [2461. 长度为 K 子数组中的最大和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/submissions/671104112/)

```c++
class Solution {
public:
    long long maximumSubarraySum(vector<int>& nums, int k)
    {
        int left=0,right=0;
        unordered_map<int,int> cnt;
        long long result=0;
        long long middle=0;
        while(right<nums.size())
        {
            middle+=nums[right];
            cnt[nums[right]]++;
            right++;

            if(right-left>k)
            {
                middle-=nums[left];
                if (--cnt[nums[left]] == 0)
                {
                    cnt.erase(nums[left]);
                }
                left++;
            }

            if(cnt.size()==k && right-left==k)
            {
                result=max(middle,result);
            }
        }    
        return result;
    }
};
```





#### [2841. 几乎唯一子数组的最大和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/)#

```c++
class Solution {
public:
    long long maxSum(vector<int>& nums, int m, int k)
    {
        int left=0,right=0;
        unordered_map<int,int> cnt;
        long long  middle=0;
        long long  result=0;

        while(right<nums.size())
        {
            middle+=nums[right];
            cnt[nums[right]]++;
            right++;
            if(right-left==k)
            {
                if(cnt.size()>=m)
                {
                    result=max(result,middle);
                }
                else
                {
                    result=result;
                }
                middle-=nums[left];
                cnt[nums[left]]--;                
                if(cnt[nums[left]] == 0) 
                {
                    cnt.erase(nums[left]);
                }               
                left++;
            }
        }  
        return result;  
    }
};
```

1.一开始初始化有问题，不应该是赋值INT_MIN，因为如果不满足是直接返回0，所以应该赋值为0.

2.我一开始处理是直接erase也是错的，假设有如下情况：

![image-20251020214118568](C:\software-1\Typora\image\image-20251020214118568.png)

其次就是要使用erase删除键值对的原因是这样：

![image-20251020214308770](C:\software-1\Typora\image\image-20251020214308770.png)



第一次重做：

```c++
class Solution {
public:
    long long maxSum(vector<int>& nums, int m, int k)
    {
        int right=0,left=0;
        long long result=0;
        long long middle=0;
        unordered_map<int,int> cnt;

        for(;right<nums.size();right++)
        {
            middle+=nums[right];
            cnt[nums[right]]++;
        
            if(right-left+1==k)
            {
                if(cnt.size()>=m)
                {
                    result=max(result,middle);
                }
                middle-=nums[left];
                cnt[nums[left]]--;
                if(cnt[nums[left]]==0)
                {
                    cnt.erase(nums[left]);
                }

                left++;
            }
        }
        return result;  
    }
};
```

这道题的指的是种类的个数，不是每个元素的个数。



#### [3679. 使库存平衡的最少丢弃次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-discards-to-balance-inventory/)

```c++
class Solution {
public:
    int minArrivalsToDiscard(vector<int>& arrivals, int w, int m) {
        int left=0,right=0;
        unordered_map<int,int> cnt;
        int result=0;
        while(right<arrivals.size())
        {            
            cnt[arrivals[right]]++;
            right++;
            
            if(right-left==w)
            {
                if(cnt.size()==m)
                {
                    result++;
                }
                cnt[arrivals[left]]--;
                if(cnt[arrivals[left]]==0)
                {
                    cnt.erase(arrivals[left]);
                }
                left++;
            }
        }
        return result;
    }
};
```

没用正确理解题目意思，要的是不是商品的总类型要少于m,是保留的商品类型中，一共不能出现某个商品m次。

```c++
class Solution {
public:
    int minArrivalsToDiscard(vector<int>& arrivals, int w, int m) {
        int left = 0, right = 0;
        unordered_map<int, int> cnt;
        int result = 0;

        if(w<=0)
        {return 0;}

        
        while (right < arrivals.size()) {            
            cnt[arrivals[right]]++;
            
            // 新增：立即检查当前元素是否超限（无论窗口是否满）
            if (cnt[arrivals[right]] > m) {
                result++;
                cnt[arrivals[right]]--; // 丢弃
                if (cnt[arrivals[right]] == 0) {
                    cnt.erase(arrivals[right]);
                }
            }
            
            right++; // 保持你原来的位置
            
            // 窗口收缩逻辑（当窗口大小超过 w 时）
            if (right - left > w) { // 注意：改为 > w，因为 right 已经 ++
                cnt[arrivals[left]]--;
                if (cnt[arrivals[left]] == 0) {
                    cnt.erase(arrivals[left]);
                }
                left++;
            }
        }
        return result;
    }
};
```

![image-20251024160802241](C:\software-1\Typora\image\image-20251024160802241.png)

```c++
class Solution {
public:
    int minArrivalsToDiscard(vector<int>& arrivals, int w, int m) {
        unordered_map<int,int> cnt;
        int result=0;
        int left=0;
        for(int right=0;right<arrivals.size();right++)
        {
            int &x=arrivals[right];

            if(cnt[x]==m)
            {
                result++;
                x=0;
            }
            else
            {
                cnt[x]++;
            }

           
            if(right-left+1==w)
            {
                cnt[arrivals[left]]--;
                left++;
            }
        }
        return result;
    }
};


```

这里统计的是每个元素出现的次数，不是窗口中拥有的种类，这点要区别一下（之前的有题目是总计出现的总类型）。



#### [2200. 找出数组中的所有 K 近邻下标 - 力扣（LeetCode）](https://leetcode.cn/problems/find-all-k-distant-indices-in-an-array/description/)

```c++
class Solution {
public:
    vector<int> findKDistantIndices(vector<int>& nums, int key, int k)
    {
        int last=-k-1;

        for(int i=k-1;i>=0;i--)
        {
            if(nums[i]==key)
            last=i;
            break;
        }

        vector<int> ans;
        for(int i=0;i<nums.size();i++)
        {
            if(i+k<nums.size() && nums[i+k]==key)
            {
                last=i+k;
            }
            if(last>=i-k)
            {
                ans.push_back(i);
            }
        }
        return ans;
    }
};
```

![image-20251028102632749](C:\software-1\Typora\image\image-20251028102632749.png)

#### [1423. 可获得的最大点数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description/)

```c++
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k)
    {
        int left=0,right=0;
        int sum=0;
        int result=INT_MAX;
        int nummax=0;

        for(int i=0;i<cardPoints.size();i++)
        {
            nummax+=cardPoints[i];
        }

        if (k == cardPoints.size()) 
        {
            return nummax;
        }
        
        for(;right<cardPoints.size();right++)
        {
            sum+=cardPoints[right];
            if(right-left+1==cardPoints.size()-k)
            {
                result=min(result,sum);
                sum-=cardPoints[left];
                left++;
            }
        }      
        return nummax-result;
    }
};
```



[1423. 可获得的最大点数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/)

思路:

![image-20251103143635125](C:\software-1\Typora\image\image-20251103143635125.png)

```c++
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k)
    {
        int left=0,right=0;
        int sum=0;
        int result=INT_MAX;
        int nummax=0;

        for(int i=0;i<cardPoints.size();i++)
        {
            nummax+=cardPoints[i];
        }

        if (k == cardPoints.size()) 
        {
            return nummax;
        }
        
        for(;right<cardPoints.size();right++)
        {
            sum+=cardPoints[right];
            if(right-left+1==cardPoints.size()-k)
            {
                result=min(result,sum);
                sum-=cardPoints[left];
                left++;
            }
        }      
        return nummax-result;
    }
};
```



使用环形数组的方式进行滑动窗口：

之前范了一个错误就是这样一种情况：只能从头尾开始取，就不太可能一下取中间的k张，于是滑动窗口能滑动的次数就只有k次。

![image-20251103150840677](C:\software-1\Typora\image\image-20251103150840677.png)

```c++
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k)
    {
        int left=0,right=0;
        int sum=0;
        int result=INT_MAX;
        int nummax=0;

        int n=cardPoints.size();
        if (k == cardPoints.size()) 
        {
            for(int i=0;i<cardPoints.size();i++)
            {
                nummax+=cardPoints[i];
            }
            result=nummax;
            return result;
        }

        if(k==0) return 0;

        //初始化窗口 从后k位开始往前
        for(int i=n-k;i<n;i++)
        {
            sum+=cardPoints[i];
        }
        result=sum;

        for(;right<k;right++)
        {
            sum+=cardPoints[right];
            sum-=cardPoints[n-k+right];

            result=max(result,sum);
        }      
        return result;
    }
};
```



### 越短越合法/求最长/最大

#### [ 3.无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)

开始的错误解法，主要是收割答案出现错误:

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s)
    {
        int right=0,left=0;
        int result=0;
        unordered_map<char,int> cnt;
        for(int right=0;right<s.size();right++)
        {
            char &x=s[right];
            cnt[x]++;

            while(cnt[x]>1)
            {
                 int middle=right-left+1;
            	result=max(middle,result);
                char d=s[left];
                left++;
                cnt[d]--;
            }
       
        }
        return result;
    }
};
```

出现这样的错误主要有2点没有考虑到：
1.是这样的情况，如果没有重复不进入while永远不更新结果：

![image-20251029094920805](C:\software-1\Typora\image\image-20251029094920805.png)

2.没有正确理解当前窗口的大小，目前维护的是多少导致思路出现问题，其次就是代码逻辑循环有问题，觉得一定会进入while。总结就是维护当前窗口的结果。

正确思路：

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s)
    {
        int right=0,left=0;
        int result=0;
        unordered_map<char,int> cnt;
        for(int right=0;right<s.size();right++)
        {
            char &x=s[right];
            cnt[x]++;

            while(cnt[x]>1)
            {
                char d=s[left];
                left++;
                cnt[d]--;
            }
            int middle=right-left+1;
            result=max(middle,result);
        }
        return result;
    }
};
```



[3090. 每个字符最多出现两次的最长子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/description/)

```c++
class Solution {
public:
    int maximumLengthSubstring(string s) 
    {
        int right=0,left=0;
        unordered_map<char,int> cnt;
        int middle=0;
        int result=0;
        for(;right<s.size();right++)
        {
            char &x=s[right];
            cnt[x]++;

            while(cnt[x]>2)
            {
                char d=s[left];
                left++;
                cnt[d]--;
            }
            middle=right-left+1;
            result=max(middle,result);
        }    
        return result;
    }
};
```





#### [1493. 删掉一个元素以后全为 1 的最长子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/)

这道题的难点在于将题目的意思转化一下，就是转化为找至多存在一个0的最长数组（最后再减一即可）

```c++
class Solution {
public:
    int longestSubarray(vector<int>& nums)
    {
        int right=0,left=0;
        int middle=0;
        int result=0;
        unordered_map<int,int> cnt;
        for(;right<nums.size();right++)
        {
            int &x=nums[right];
            cnt[x]++;

            while(cnt[0]>=2)
            {
                cnt[nums[left]]--;
                left++;
            }
            middle=right-left;
            result=max(result,middle);
        }
        return result;
    }
};
```



#### [3634. 使数组平衡的最少移除数目 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-removals-to-balance-array/description/)#

一开始想到排序后，然后就不知道怎么处理了，看了答案是使用反向的思维来解答。

![image-20251104091346920](C:\software-1\Typora\image\image-20251104091346920.png)



![image-20251104091426891](C:\software-1\Typora\image\image-20251104091426891.png)

```c++
class Solution {
public:
    int minRemoval(vector<int>& nums, int k)
    {
        sort(nums.begin(),nums.end());
        int right=0,left=0;
        int middle=0;
        int result=0;

        for(;right<nums.size();right++)
        {
            while(1LL*nums[left]*k<nums[right])
            {
                left++;
            }
            result=max(result,right-left+1);
        }
    }
    return nums.size()-middle;
};
```



#### [1208. 尽可能使字符串相等 - 力扣（LeetCode）](https://leetcode.cn/problems/get-equal-substrings-within-budget/submissions/675680859/)

```c++
class Solution {
public:
    int equalSubstring(string s, string t, int maxCost)
    {
        //vector<int> nums;
        vector<int> nums(s.size());
        int right=0,left=0;
        int middle=0;
        int result=0;
        for(int i=0;i<s.size();i++)
        {
            nums[i]=abs(s[i]-t[i]);
        }

        for(;right<nums.size();right++)
        {
            middle+=nums[right];

            while(middle>maxCost)
            {
                middle-=nums[left];
                left++;
            }
            result=max(result,right-left+1);
        }
    return result;
    }
};
```

这里唯一的错误就是初始化vector的时候，这个动态数据初始化的时候是需要分配空间的。



#### [1695. 删除子数组的最大得分 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-erasure-value/)

```c++
class Solution {
public:
    int maximumUniqueSubarray(vector<int>& nums)
    {
        int right=0,left=0;
        int result=0;
        int middle=0;
        unordered_map<int,int> cnt;

        for(;right<nums.size();right++)
        {
            cnt[nums[right]]++;
            middle+=nums[right];

            while(cnt[nums[right]]>1)
            {
                cnt[nums[left]]--;
                middle-=nums[left];
                left++;
            }
            result=max(result,middle);
        }
        return result;
    }
};
```

第一次就通过。



#### [2958. 最多 K 个重复元素的最长子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/length-of-longest-subarray-with-at-most-k-frequency/submissions/675968910/)

```c++
class Solution {
public:
    int maxSubarrayLength(vector<int>& nums, int k)
    {
        int right=0,left=0;
        int result=0;
       
        unordered_map<int,int> cnt;

        for(;right<nums.size();right++)
        {
            cnt[nums[right]]++;
    
            while(cnt[nums[right]]>k)
            {
                cnt[nums[left]]--;
                left++;
            }
            result=max(result,right-left+1);
        }
        return result;
    }
};
```



### [2024. 考试的最大困扰度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/#

```c++
class Solution {
public:
    int maxConsecutiveAnswers(string answerKey, int k)
    {
        int right=0,left=0;
        int middle=0;
        int result=0;
        int t=0,f=0;
        for(;right<answerKey.size();right++)
        {
            if(answerKey[right]=='T')
            {
                t++;
            }
            else
            {
                f++;
            }

            while(min(t,f)>k)
            {
                if(answerKey[left]=='T')
                {
                    t--;
                }
                if(answerKey[left]=='F')
                {
                    f--;
                }
                left++;
            }
            result=max(result,right-left+1);
        }
        return result;
    }
};
```

这道题有一点像连续找出都是1的一道题，可以有一次修改其他值为1的机会，因此那道题的思路就是找允许有一个不唯1的连续最长数组。这道题他需要维护的是2个字符，因此一开始不知道如何处理。

**窗口越大越难满足，越小越容易满足”的性质，就叫“单调性”，正是滑动窗口适用的核心前提！**

![image-20251106100608226](C:\software-1\Typora\image\image-20251106100608226.png)



#### [1004. 最大连续1的个数 III - 力扣（LeetCode）](https://leetcode.cn/problems/max-consecutive-ones-iii/)



```c++
class Solution {
public:
    int longestOnes(vector<int>& nums, int k)
    {
        int right=0,left=0;
        int middle=0;
        int result=0;
        int fal=0;

        for(;right<nums.size();right++)
        {
            if(nums[right]==0)
            {
                fal++;
            }
        
            while(fal>k)
            {
                if(nums[left]==0)
                {
                    fal--;
                }
                left++;
            }
            result=max(result,right-left+1);
        }    
        return result;
    }
};
```







### [209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/submissions/676448192/)

![image-20251107111315667](C:\software-1\Typora\image\image-20251107111315667.png)



这里不通过的原因就是更新结果在while外，已经不满足target条件才更新

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums)
    {
        int right=0,left=0;
        int middle=0;
        int result=INT_MAX;

        for(;right<nums.size();right++)
        {
            middle+=nums[right];

            while(middle>=target)
            {
                middle-=nums[left];
                left++;
            }
            result=min(result,right-left+1);
        }
        return result;
    }
};
```



```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums)
    {
        int right=0,left=0;
        int middle=0;
        int result=INT_MAX;

        for(;right<nums.size();right++)
        {
            middle+=nums[right];

            while(middle>=target)
            {
                result=min(result,right-left+1);
                middle-=nums[left];
                left++;
            }
           
        }
        return result==INT_MAX? 0:result;
    }
};
```



#### [930. 和相同的二元子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-subarrays-with-sum/)

.这个是恰好型的滑动窗口的题目，通过至多k个-至多k+1个就可以计算出恰好k个。这个数学逻辑就是>=k减去>=k+1。

因此将其转化为越长越合法的滑动窗口，因此答案的收割在内循环while结束后答案收割为：result+=left;

```c++
class Solution {
public:
    int numSubarraysWithSum(vector<int>& nums, int goal)
    {
        return solve(nums, goal)-solve(nums, goal+1);
    }

    int solve(vector<int>& nums, int goal)
    {
        int left=0,right=0;
        int result=0;
        int middle=0;

        if (goal == 0) return nums.size() * (nums.size() + 1) / 2;

        for(;right<nums.size();right++)
        {
            middle+=nums[right];
            while(middle>=goal)
            {
                middle-=nums[left];
                left++;
            }
            result+=left;
        }
        return result;
    }
};
```

其次 if (goal == 0) return nums.size() * (nums.size() + 1) / 2;这个代码相关重要，如果不加goal等于0的时候，left会一直加，导致数组越界。因此在做题的时候要额外考虑一下边界条件。



### 一、[最小覆盖子串]([76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/description/))

对于字符串就是判断字符的个数是否符合就可以了，因为长度被第二个while的条件限制了。

```c++
class Solution {
public:
    string minWindow(string s, string t) 
    {
        unordered_map<char,int> need,window;

        //记录每个字符出现的次数
        for(char c:t)
        {
            need[c]++;
        }

        int left=0,right=0;
        int valid=0;//记录是否满足条件
        int start=0,len=INT_MAX;

        while(right<s.size())
        {
            //增加右窗口
            char c=s[right];
            right++;
            if(need.count(c))
            {
                window[c]++;//记录次数
                if(window[c]==need[c])//检查数量是否满足
                    valid++;
            }

            while(valid==need.size())
            {
                //更新结果
                if(right-left<len)
                {
                    start=left;
                    len=right-left;
                }

                //缩小左边窗口
                char d=s[left];
                left++;

                if(need.count(d))
                {
                    if(window[d]==need[d])
                    {
                       	 valid--;
                    }
                      
                    window[d]--;
                }
            }
        }
    return len==INT_MAX? "":s.substr(start,len);
    }
};
```

其中这个语句中:

```c++
while(valid==need.size())和t.size（）
```

这2个语句是不一样的结果，主要是针对出现t中如果有重复的字符的情况。如果出现重复字符，need.size算的是键值对的数量也就是还是3，但是t的话算的是字符的长度。

其中下面的这个语句也是在处理如果出现字符重复的情况下，数目上也要要求一直

```c++
 if(need.count(c))
{
    window[c]++;
    if(window[c]==need[c])
    {
        valid++;
    }
}
```





### 二、[找到字符串中所有字母异位]([438. 找到字符串中所有字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/))

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p)
    {
        int left=0;
        int right=0;
        unordered_map<char,int> need,window;
        int valid=0;
        vector<int> result;
        
        for(char c:p)
        {
            need[c]++;
        }
        while(right<s.size())
        {
            char c=s[right];
            right++;
            if(need.count(c))
            {
                window[c]++;
                if(window[c]==need[c])
                    valid++;
            }
            while(right-left>=p.size())
            {
                
                if(valid==need.size())
                {
                    result.push_back(left);
                }
                    

                char d=s[left];
                left++;
                if(need.count(d))
                {
                    if(need[d]==window[d]) 
                        valid--;
                    window[d]--;
                }
            }
        }
        return result;    
    }
};
```



### 三、[字符串排列]([567. 字符串的排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutation-in-string/description/))

```c++
class Solution {
public:
    bool checkInclusion(string s1, string s2) 
    {
        int left=0;
        int right=0;
        unordered_map<char,int> need,window;
        int valid=0;
        for(char c:s1)
        {
            need[c]++;
        }
        while(right<s2.size())
        {
            char c=s2[right];
            right++;
            if(need.count(c))
            {
                window[c]++;
                if(window[c]==need[c])
                    valid++;
            }
            while(right-left>=s1.size())
            {
                if(valid==need.size())
                    return true;

                char d=s2[left];
                left++;
                if(need.count(d))
                {
                    if(need[d]==window[d]) 
                        valid--;
                    window[d]--;
                }
            }
        }
        return false;
    }
};
```



### 四、[最长无重复子串]([3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/))

1.为什么结果是放在后面？->因为放在后面才是符合结果，就是更新后的结果，这样处理之后才会不会有重复的字符。

2.为什么直接更新结果不对？如图所示

![image-20250819113457615](C:\software-1\Typora\image\image-20250819113457615.png)

原因就是还是没有去除重复的字符才更新。如果是目标是“abc”,给出的字符串是abca,如果放在这个位置right=4,left=0,结果是4-0为4显然不对。

3.为什么这个接力结果有100多个不对？

![image-20250818220627628](C:\software-1\Typora\image\image-20250818220627628.png)

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) 
    {
        int left=0;
        int right=0;
        unordered_map<char,int> window;
        int valid=0;
        int result=0;


        while(right<s.size())
        {
            char c=s[right];
            right++;
            window[c]++;
           
            while(window[c]>1)
            {
               
               
                char d=s[left];
                left++;
                window[d]--;

                if(right-left>result)
                {
                    result=right-left;
                }
            
            }
        }
        return result;
    }
};
```

原因还是因为没有在去除重复数组更新，但是因为有些序列可以满足只减去一个窗口就满足条件。例子dvdf中，目标明显是vdf,应该为3，但是在处理第二个d的时候结果是2导致不对。



针对以上的问题，正确答案应该是在while处理完之后再更新结果，这样才不会出现重复子串的情况。
