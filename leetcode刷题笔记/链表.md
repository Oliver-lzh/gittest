# 链表

### 链表基础

c语言定义如下：

```c
typedef struct ListNodeT {
    int val;
    struct ListNodeT next;
} ListNode;
```

这种定义将结构体直接用ListNode替代定义中的struct ListNode.

其他基础定义：

```c
struct Student   //定义一个名为Student的结构体
{
	char name[20];  //姓名
	int id;  //学号
	char sex;  //性别（1：男  0：女）
	int age;  //年龄
	int score;  //总成绩
};
struct Student stu;  //定义一个结构体变量

```

```c
struct Student   //定义一个名为Student的结构体
{
	char name[20];  //姓名
	int id;  //学号
	char sex;  //性别（1：男  0：女）
	int age;  //年龄
	int score;  //总成绩
}stu;  //在结构体声明的同时定义一个结构体变量stu

```



## 一、设计链表

```c
void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) 

{
  MyLinkedList *cur=obj;

  for(int i=0;cur->next!=NULL;i++)

  {
    cur=cur->next;

    if(i==index)

    {
    }
}
```

### Q1

这里出现的问题就是：当时找到索引值的目标后，cur指针指向的是index这个节点的，但是我要操作的是index前面的一个节点，因此需要让循环变快一个单位相对于索引。

解决方法如下；

```c
 for(int i=1;cur!=NULL;i++)//把循环变快，cur的更新变慢一个
 {
 
 }
```

### Q2

链表有时候是创建新的节点，分配内存；有时候只要定义变量。

选择的标准就是：如果这个节点操作完以后还是存在于节点中的，那么就要申请内存；如果只是为了暂时的使用来帮助指针的转换问题，那么就要定义完free就可以。

### Q3

这个代码存在的问题就是没有把虚拟的头结点开始删除

```C
void myLinkedListFree(MyLinkedList* obj) 

{

  MyLinkedList *cur=obj->next;

  while(cur->next!=NULL)

  {

    MyLinkedList *tmp=cur;

    cur=cur->next;

    free(tmp);

  }

}

```

正确的代码如下：

```c
void myLinkedListFree(MyLinkedList* obj) 
{
    while(obj->next!=NULL)
    {
        MyLinkedList *tmp=obj;
        obj=obj->next;
        free(tmp);
    }
}
```



### Q4

![image-20240719101921970](C:\software-1\Typora\image\image-20240719101921970.png)

cur指向真正的头节点，下面while循环会超时？



### 题解

```c



typedef struct MyLinkedList{
    int val;
    struct MyLinkedList *next;
} MyLinkedList;



MyLinkedList* myLinkedListCreate() 
{
    MyLinkedList *head;
    head=(MyLinkedList *)malloc(sizeof(MyLinkedList));
    head->next=NULL;
    return head;
}


//第一个参数传入是头结点的
int myLinkedListGet(MyLinkedList* obj, int index) 
{
    MyLinkedList *cur = obj->next;
    for (int i = 0; cur != NULL; i++){
        if (i == index){
            return cur->val;
        }
        else{
            cur = cur->next;
        }
    }
    return -1;
}

void myLinkedListAddAtHead(MyLinkedList* obj, int val) 
{
    //这里传入的obj是虚拟的头结点
    MyLinkedList *head=(MyLinkedList *)malloc(sizeof(MyLinkedList));
    head->val=val;
    head->next=obj->next;
    obj->next=head;
}

void myLinkedListAddAtTail(MyLinkedList* obj, int val)
{
    MyLinkedList *cur=obj;
    //一直寻找使得cur指向了链表的最后，方便进行后续的操作。
    while(cur->next!=NULL)
    {
        cur=cur->next;
    }
    //申请一个尾部的节点,初始化
    MyLinkedList *nail=(MyLinkedList *)malloc(sizeof(MyLinkedList));
    nail->val=val;
    cur->next=nail;
    nail->next=NULL;
}

void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) 
{
   if(index==0)
   {
        myLinkedListAddAtHead(obj,val);
        return ;
   }
    //指向真正的头结点
    MyLinkedList *cur=obj->next;
    for(int i=1;cur!=NULL;i++)//把循环变快，cur的更新变慢一个
    {
        if(i==index)
        {
            MyLinkedList *newnode=(MyLinkedList *)malloc(sizeof(MyLinkedList));
            newnode->val=val;
            newnode->next=cur->next;
            cur->next=newnode;
            return ;
        }
        else
        {
            cur=cur->next;
        }
    }
}


void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index)
{
    if(index==0)
    {
        MyLinkedList *tmp=obj->next;
        if(tmp!=NULL)
        {
            obj->next=tmp->next;
            free(tmp);
        }
        return ;
    }

     MyLinkedList *cur=obj->next;
     for(int i=1;cur!=NULL;i++)
     {
        if(i==index)
        {
            MyLinkedList *tmp;
            tmp=cur->next;
            if(tmp!=NULL)
            {
                cur->next=tmp->next;//等同于 cur->next=cur->next->next;
                free(tmp);
            }
            return ;
        }
        else
        {
            cur=cur->next;
        }
     }
}

//细节就是要一个个节点删除，不是只删除头结点
void myLinkedListFree(MyLinkedList* obj) 
{
    while(obj->next!=NULL)
    {
        MyLinkedList *tmp=obj;
        obj=obj->next;
        free(tmp);
    }
}

/**
 * Your MyLinkedList struct will be instantiated and called as such:
 * MyLinkedList* obj = myLinkedListCreate();
 * int param_1 = myLinkedListGet(obj, index);
 
 * myLinkedListAddAtHead(obj, val);
 
 * myLinkedListAddAtTail(obj, val);
 
 * myLinkedListAddAtIndex(obj, index, val);
 
 * myLinkedListDeleteAtIndex(obj, index);
 
 * myLinkedListFree(obj);
*/
```





## 二、翻转链表



尝试做法：

```c
struct ListNode* reverseList(struct ListNode* head)
{
    typedef struct ListNode ListNode;
    ListNode *fast;
    ListNode *slow;

    slow=head;
    fast=slow->next;

    if(head!=NULL)
    {
        head->next=NULL;
    }
    else
    {
        return head;
    }

    while(fast!=NULL)
    {
        ListNode *tmp;
        tmp=fast;
        fast=fast->next;
        tmp->next=slow;
        slow=tmp;
    }
    return fast;
}
```

正确交换

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* reverseList(struct ListNode* head)
{
    typedef struct ListNode ListNode;
    ListNode *fast;
    ListNode *slow;
    ListNode *tmp;
    slow=NULL;
    fast=head;

    while(fast)
    {
        tmp=fast->next;
        fast->next=slow;
        slow=fast;
        fast=tmp;
    }
    return slow;
}
```

递归

```c
struct ListNode*reverse(struct ListNode *pre,struct ListNode *cur)
{
    struct ListNode *tmp;
    if(!cur)
    {
        return pre;
    }
    tmp=cur->next;
    cur->next=pre;
    return  reverse(cur,tmp);//移动一个位置


}

struct ListNode* reverseList(struct ListNode* head)
{
    return reverse(NULL,head);
}
```



## 三、俩俩交换节点

### Q1

 while的循环条件开始不确定

解答：在操作2个节点的时候，需要知道这2个节点前的一个位置。因此，当节点为奇数的时候，循环的终止条件是cur->next->next==NULL；当为偶数的时候终止的调节为cur->next==NULL。

**注意！！！**这里的循环条件一定要cur->next写在前面，否则如果cur->nex如果为空，再对它的next进行操作就是操作空指针了，会报错。

### Q2

leetcode链表题报错 runtime error: member access within null pointer of type ‘ListNode‘。

出现这个报错是因为对ListNode这一结构体此时已经是空指针，再对这个空指针进行了操作。

例如：

```c
while(n->next!=NULL&&n!=NULL)
    
```

这个代码就会出现此问题，如果n已经为空指针的，那么n再对next进行操作就是操作了空指针。

刷题错误出现在tmp变量指向的是头结点，而不是虚拟头节点产生的，如下：

![30557de1a1d6e915ea458815e9effe8](C:\software-1\Typora\image\30557de1a1d6e915ea458815e9effe8.png)

头结点如果是空的话，那么tmp->next这个语句就对空节点进行操作了，因此会报错。

### Q3

在处理交换后的节点后，在后面的节点反而是node1。

![image-20240805200819351](C:\software-1\Typora\image\image-20240805200819351.png)



尝试

```c
struct ListNode* swapPairs(struct ListNode* head)
{
    typedef struct ListNode ListNode;

    //初始化虚拟头结点
    ListNode *shead=(ListNode *)malloc(sizeof(ListNode));
    shead->next=head;
    ListNode *cur=shead;

    while(cur->next!=NULL&&cur->next->next!=NULL)
    {
        //在进行交换之前要保存相关节点的位置
        ListNode *tmp=cur->next;
        ListNode *tmp1=cur->next->next->next;

        //交换
        cur->next=cur->next->next;
        cur->next->next=tmp;
        tmp=tmp1;

        //移动操作节点
        cur=cur->next->next;
    }

    head=shead->next;
    free(shead);
    return head;
}
```



### 题解

代码

```c
struct ListNode* swapPairs(struct ListNode* head)
{
    typedef struct ListNode ListNode;
    ListNode *fakehead = (ListNode *)malloc(sizeof(ListNode));
    fakehead->next = head;
    ListNode *tmp=fakehead;
    while(tmp->next!=NULL && tmp->next->next!=NULL)
    {
        ListNode *node1=tmp->next;
        ListNode *node2=tmp->next->next;

        tmp->next=node2;
        node1->next=node2->next;
        node2->next=node1;
        tmp=node1;
    }
    return fakehead->next;//tmp一直在变化，但是fakehead不会变化。
}
```



注意：![image-20240728212806080](C:\software-1\Typora\image\image-20240728212806080.png)

这2行的代码不能更换顺序，要先对node1操作之后，再操作node2。如果先操作node2，那么node2的next就变了，进行node1赋值node2->next的时候就不是node2的原本的下一个节点，而是node1，矛盾语句了（node1->next=node1）

![image-20240724161802694](C:\software-1\Typora\image\image-20240724161802694.png)



## 四、删除链表的倒数n节点

### 思路

定义2个快慢指针，先让fast指针向前移动n+1个节点，然后快慢指针同时移动，结束条件就是fast指针空的时候，那么因为fast是向前移动过，slow指针刚好落后n+1个节点，最后对slow指针进行删除操作。

- 为什么不是fast先移动n个节点 原因：因为删除要知道该节点的前一个指针，因此slow要落后的是n+1而不是n个节点。

![image-20240729094303516](C:\software-1\Typora\image\image-20240729094303516.png)

一次通过。

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* removeNthFromEnd(struct ListNode* head, int n)
{
    typedef struct ListNode ListNode;
    ListNode *fakehead=(ListNode *)malloc(sizeof(ListNode));
    fakehead->next=head;

    ListNode *fast=fakehead;
    ListNode *slow=fakehead;

    //2 0 1
    for(int i=0;i<=n;i++)
    {
        fast=fast->next;
    }

    //同时移动指针，使得fast指向最后的NULL
    while(fast)
    {
        slow=slow->next;
        fast=fast->next;
    }

    //删除对应结点
    ListNode *tmp;
    tmp=slow->next;
    slow->next=slow->next->next;
    free(tmp);

    return fakehead->next;
}
```



五、

```c
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB)
{
    typedef struct ListNode ListNode;
    ListNode *tmp1=(ListNode *)malloc(sizeof(ListNode));
    ListNode *tmp2=(ListNode *)malloc(sizeof(ListNode));

    int Alength=0;
    int Blength=0;

    tmp1->next=headA;
    tmp2->next=headB;

    ListNode *node1=tmp1;
    ListNode *node2=tmp2;

    while(tmp1->next!=NULL)
    {
        Alength++;    
        tmp1=tmp1->next;    
    }
    while(tmp2->next!=NULL)
    {
        Blength++;
        tmp2=tmp2->next;
    }
    if(tmp2->val!=tmp1->val)
    {
        return NULL;
    }


    if(Alength>Blength)
    {
        int err=Alength-Blength;
        for(int i=0;i<err;err++)
        {
            node1=node1->next;
        }
        while(headA->next->val!=headB->next->val)
        {
            node1=node1->next;
            node2=node2->next;
        }
        return node1;
    }
    else
    {
        int err=Alength-Blength;
        for(int i=0;i<err;err++)
        {
           node2=node2->next;
        }
        while(node1->next->val!=node2->next->val)
        {
            node1=node1->next;
            node2=node2->next;
        }
        return node2;
    }
}
```



题解：

```c
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB)
{
    typedef struct ListNode ListNode;
    int Alength=0;
    int Blength=0;
    int gap=0;

    ListNode *node1=NULL;
    ListNode *node2=NULL;

    node2=headA;
    while(node2)
    {
        Alength++;    
        node2=node2->next;    
    }
    node2=headB;
    while(node2)
    {
        Blength++;
        node2=node2->next;
    }
  
    //求链表长度差值
    if(Alength>Blength)
    {
        //复位
        node1=headA;
        node2=headB;
        gap=Alength-Blength;
    }
    else
    {
        node1=headB;
        node2=headA;
        gap=Blength-Alength;
    }

    //对齐
    while(gap--)
    {
        node1=node1->next;
    }

    while(node1)
    {
        if(node1==node2)
        {return node1;}
        node1=node1->next;
        node2=node2->next;
    }

    return NULL;
}
```



## 五、环形链表

```c
struct ListNode *detectCycle(struct ListNode *head)
{
    typedef struct ListNode ListNode;
    ListNode *fast=head,*slow=head;

    while(fast&&fast->next)//判断fast->next不为空才不会操作空指针
    {
        slow=slow->next;
        fast=fast->next->next;
        if(slow==fast)//指针的地址相同
        {
            ListNode *index=fast,*index1=head;
            while(index!=index1)
            {
                index=index->next;
                index1=index1->next;
            }
            return index;
        }
    }
    return NULL;
}
```





## 六、链表相交

### Q1

```c
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB)
{
    typedef struct ListNode ListNode;
    int LengthA=0,LengthB=0;
    int err=0;

   

    while(headA)
    {
        LengthA++;
        headA=headA->next;        
    }
    while(headB)
    {
        LengthB++;
        headB=headB->next;        
    }

    if(LengthA>LengthB)
    {
        err=LengthA-LengthB;
        for(int i=0;i<err;i++)
        {
            headA=headA->next;
        }
    }
    else
    {
        err=LengthB-LengthA;
        for(int i=0;i<err;i++)
        {
            headB=headB->next;
        }
    }

    while(headA)
    {
        if(headA==headB)
        {
            return headA;
        }
        headA=headA->next;
        headB=headB->next;
    }
    return NULL;
}
```

错误原因发生在如下：

原因：在一开始移动头指针的时候，头指针已经指向null，后续对这个链表进行操作就会对空指针进行操作，因此会出现错误。

解决方法：在遍历链表的时候，用一个中间变量来遍历，不改变头指针的指向。

![image-20240805203133393](C:\software-1\Typora\image\image-20240805203133393.png)

题解：

```c
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB)
{
    typedef struct ListNode ListNode;
    int LengthA=0,LengthB=0;
    int err=0;

   ListNode *node1=headA;
   ListNode *node2=headB;

    while(node1)
    {
        LengthA++;
        node1=node1->next;        
    }
    while(node2)
    {
        LengthB++;
        node2=node2->next;        
    }

    if(LengthA>LengthB)
    {
        err=LengthA-LengthB;
        for(int i=0;i<err;i++)
        {
            headA=headA->next;
        }
    }
    else
    {
        err=LengthB-LengthA;
        for(int i=0;i<err;i++)
        {
            headB=headB->next;
        }
    }

    while(headA)
    {
        if(headA==headB)
        {
            return headA;
        }
        headA=headA->next;
        headB=headB->next;
    }
    return NULL;
}
```



## 本章不熟悉题目：设计链表 环形链表
